========================================总结===========================================

​	严格意义上来说，只刷了四天；按照一定顺序来刷会更快，也会更省力；因此我改变一下代码随想录的这些数据结构的题目的刷题顺序（不包含karl网的题目和图的题目），一共是67道题目。有一小部分很难，我就跳过了。

​	这一次不追求超过100%，能ac即可，哪怕暴力也可也；用C++刷题，以后不要用Python了，重新写一下用Python的。

# 难题【8-待解决】

1.【28】实现StrStr()

2.【347】前k个高频元素

3.【145】二叉树的后序遍历-非递归

4.【94】二叉树的中序遍历-非递归

5.【151】反转字符串中的单词

6.【15】三数之和

7.【18】四数之和

8.【239】滑动窗口最大值

# 简单题【60】

## 数组[13]

-- 难度依次增加；第一题是一道锻炼循环边界意识的题目；第二道是经典的二分查找；第三和第四是双指针；最后一题是滑动窗口。

1.【59】螺旋矩阵2

2.【704】二分查找

3.【27】移除元素

4.【977】有序数组的平方

5.【344】反转字符串

6.【242】有效的字母异位词

7.【349】两个数组的交集

8.【1】两数之和

9.【202】快乐数

10.【541】反转字符串2

11.【459】重复的子字符串

12.【454】四数相加II

13.【209】长度最小的子数组

## 链表[7]

-- 我觉得5，6，7可能会需要想一下细节，其它不难，环形链表用哈希的思想很简单的；

1.【19】删除链表的倒数第N个节点

2.【203】移除链表元素

3.【160】链表相交

4.【142】环形链表II

5.【707】设计链表

6.【206】反转链表

7.【24】两两交换链表中的节点

## 队列和栈[6]

1.【144】二叉树的先序遍历-非递归

2.【232】用栈实现队列

3.【20】有效的括号

4.【1047】删除字符串中的所有相邻重复项

5.【150】逆波兰表达式求值

6.【225】用队列实现栈

## 二叉树[34]

### DFS

1.【144】二叉树的先序（中序、后序遍历类似）

2.【104】二叉树的最大深度

3.【222】完全二叉树的节点个数

4.【112】路径总和

5.【404】左叶子之和

6.【501】二叉搜索树中的众数

7.【226】翻转二叉树

8.【101】对称二叉树

9.【538】把二叉搜索树转换为累加树

10.【617】合并二叉树

11.【654】最大二叉树

12.【106】从中序和后序序列构造二叉树

13.【105】从前序和中序序列构造二叉树

### BFS

1.【102】二叉树层序遍历

2.【107】二叉树层序遍历2

3.【199】二叉树的右视图

4.【637】二叉树的层平均值

5.【429】N叉树的层序遍历

6.【515】在每个树行中找最大值

7.【116】填充每一个节点的下一个右侧节点指针

8.【117】填充每一个节点的下一个右侧节点指针2

9.【111】二叉树的最小深度

10.【513】找树左下角的值

11.【236】二叉树的最近公共祖先

12.【235】二叉搜索树的最近公共祖先

### BST和AVL

1.【110】平衡二叉树

2.【98】验证二叉搜索树

3.【700】二叉搜索树中的搜索

4.【701】二叉搜索树中的插入操作

5.【530】二叉搜索树的最小绝对差

6.【669】修剪二叉搜索树

7.【108】将有序数组转换为二叉搜索树

8.【450】删除二叉搜索树中的节点

### 其它

1.【257】二叉树的所有路径【回溯】

=================================2025.7.11====================================

# 力扣∩代码随想录-数组链表字符串

-- 线性表的练习，主要是数组、单链表、字符串、队列栈；能调库的就调库了。

1.二分查找（√）

​	我想说：可以选择循环或递归，我习惯用循环写二分；二分要注意的是mid的计算不要超过int的范围；要注意left和right是闭区间，那么更新mid的时候也要考虑这一点。

2.移除元素（√）

​	我想说：原地删除，快慢双指针，快指针一直自然前进，慢指针负责接收最后结果有用的部分。

3.有序数组的平方（√）

​	我想说：左右内收双指针，**还可以优化**时间复杂度。

4.长度最小的子数组（√）

​	我想说：滑动窗口，维护一个最小的sustain窗口，使得窗口内的数加起来>=target；第一点，要注意我们没有必要分两段处理，只需要遍历的过程中，都收集就可以了，如果目前不够target，后面的代码continue的效果即可；第二个也是我出错的一点就是：在满足summary>=target的前提下，先计算窗口大小还是先瘦身的问题，答案是要先瘦身；再计算窗口大小-因为我们需要的是最小的窗口大小，只有瘦身达到summary < target，说明left到位了，自然left-1的位置，就是刚好满足summary >= target的位置，不多不少。由于这个题值得多次品味，现在刷了很多遍感觉难度比第一次刷简单很多。

​	还有一个小错误：变量名不要和内置函数sum冲突。

```python
class Solution(object):
    def minSubArrayLen(self, target, nums):
        """
        :type target: int
        :type nums: List[int]
        :rtype: int
        """
        # 安全性检查-可能凑不够
        if sum(nums) < target:
            return 0
        # 滑动窗口-sustain
        summary = 0
        left = 0
        ret = len(nums)
        for i in range(len(nums)):
            summary += nums[i]
            if summary >= target:
                # 尝试让窗口不满足要求
                while summary >= target and left <= i:
                    summary -= nums[left]
                    left += 1
                # 计算窗口大小
                ret = ret if i - (left-1) + 1 > ret else i - (left-1) + 1
        return ret
```

5.螺旋矩阵2

​	我想说：Python的初始化一个数组的时候，要注意区分这几个点；

①`nums = [0 * 3]` 注意，这不是列表推导式，列表推导式不能这么用，如果想初始化一个3个长度的常数数组，有两种写法

* `nums = [0] * 3` 或者用推导式`nums = [0 for _ in range(3)]` 推荐使用第二种

②二维数组的时候，不能用乘法初始化，这样会导致外层的三个引用指向同一个一维数组，导致错误，乘法不会单独生成三份不同的地址，只能用列表推导式加循环的方式；即

`matrix = [[0 for _ in range(n)] for _ in range(n)]`

​	其它本题的注意事项就是要保持每一条边的区间开闭的一致性，推荐遵循range特性，左闭右开；第二就是奇数n的单独处理，即left == range的时候单独赋值。



`开发商购买土地，区间和不是leetcode题目，他的服务器坏了，我们就先跳过这部分`

6.移除链表元素（√）

​	我想说：数据结构手撕的肯定是CPP来写的；题目默认都是没有哨兵的；需要我们自己手动添加哨兵，然后最后返回结果的时候也要搞回去，哨兵只是辅助我们写代码easier的东西；再就是边界附近的情况单独考虑。

7.设计链表（√）

​	我想说：在特定的索引处删除或者添加元素，要注意边界处自己的逻辑是否覆盖到，比如头插的特殊情形等。链表的设计一般都是两个类，链表一个类，节点一个类，然后链表里面有一个虚拟头结点list，一个len。

8.反转链表（√）

​	我想说：操控指针，从前往后逐个翻转。核心是需要几个辅助指针的思考；指针的情况需要一边做一边微调；尤其是while的条件，我们应该上来就操作，即第一个指针指向待指结点；第二个指针指向第二个；第三个指针指向后面，防止孤岛断路。

9.删除链表的倒数第N个节点（√）

10.链表相交（√）

11.两两交换链表中的节点（√）

​	我想说：在平移的时候，不要混淆了！不要按照原来交换前的逻辑的顺序进行平移，cur1才是后面的结点。

12.环形链表II（√）

​	我想说：过了，但是不是卡码那种简单方法，我这个也好想，就是统计次数，用哈希来做。以后就用我这个吧，不用Carl那个了。

```c++
class Solution {
public:
    ListNode *detectCycle(ListNode *head) {
    	// 先检查是否有环-计数器的方式检查
    	unordered_map<ListNode*,int> mp;  // 注意写法
    	ListNode*temp = head;
    	int has_cycle = false;
    	while(temp) {
    		if(mp[temp] == 0) {
				mp[temp] ++;
			}else if(mp[temp] == 1) {
				has_cycle = true;
				break;
			}
    		temp = temp->next;	
		}
		if(!has_cycle) {
			return nullptr;
		}
		// 有环
		return temp;
    }
};
```

13.反转字符串（√）

14.反转字符串2（√）

```c++
class Solution {
public:
	void MyReverse(string&s,int st,int end) {
		// 闭区间
		while(st <= end) {
			swap(s[st],s[end]);
			st++;end--;
		}
	}
    string reverseStr(string s, int k) {
    	for(int i = 0;i < s.size();i += 2 * k) {
			int gap = s.size() - i;
			if(gap < k) {
				MyReverse(s, i, s.size()-1);
			}else{
                MyReverse(s, i, i + k - 1);
            }		
		}
		return s;
    }
};
```

​	我想说：这次我写的很简洁；思想也很简单；需要额外注意MyReverse的下标处理即可。

15.反转字符串中的单词（√）

-- 第一遍直接python，没事的，现在我们的目的是往前冲，到时候找工作的时候再用java刷，现在就只负责往前冲就好了。

```python
class Solution(object):
    def reverseWords(self, s):
        """
        :type s: str
        :rtype: str
        """
        ret = s.strip().split()
        ret = ret[::-1]
        return ' '.join(ret)
```

16.重复的子字符串（√）

​	我想说：关键是不知道这个唯一单元是谁，所以需要从小往大遍历；但是不需要每个都尝试，先用长度的倍数关系筛选一波就会很简单。剩下的就是外部i确定唯一单元，内部需要判断是否由这个单元构成。

17.实现StrStr()-KMP算法♥

①预备知识-字符串的前缀和后缀

* 前缀：包含第一个字符的原字符串的子串**<u>（全串除外）</u>**；

* 后缀：包含最后一个字符的原字符串的子串**<u>（全串除外）</u>**；

  ​	令“**一轮匹配过程**”指的是从文本串和模式串的第一个字符相同后发生的匹配过程都属于本轮匹配，当且仅当模式串和文本串在本轮中无法匹配成功，即最终答案不是当前轮文本串中的匹配成功的第一个字符的下标，当前轮次肯定不是最终答案对应的轮次。

②从BF到KMP

* BF算法时间复杂度高的根本：BF算法旨在对于每一轮匹配，一旦匹配失败，模式串需要从头再来。

* 如何理解文本串的遍历过程：文本串则正常前行即可。i只需要从0到len(s)-1，如果某个s[i]和对应的模式串匹配成功，那么这次成功可能是**一轮新的开始**，**也可能左侧近邻的元素已经匹配成功，目前仍然在匹配成功的路上**；如果某个s[i]和对应的模式串匹配失败，自然当前i不是正确答案对应的轮次的开始位置，直接continue了。

* KMP的思想：KMP避免在失配情况下，模式串重复回退到0。它旨在使用一种具有某种记忆功能的数据结构来存储一些信息，使得当某一轮匹配发生失配时，减少损失，尽最大努力寻找本轮匹配能够继续下去的最大可能情况。 举例： 要在文本串：aabaabaafa 中查找是否出现过一个模式串：aabaaf，当发生失配时，即文本串中第二个b和模式串中的f失配，“本轮”的定义是在本例中，第一个a到失配b-f的过程。值得注意的是，b和f之前的部分aabaa是匹配成功过的，而本轮中，文本串还在等待，即还渴望能在本轮中使得第二个b能配对上。**开启新的一轮-**第一个a打头的这一轮不可能是最后的答案了，让新的字符打头，这个字符是谁，不确定。但可以确定的是上一轮中b-f失配前的一部分是匹配成功过的，所以要充分利用之前成功配对的部分减少重复比较。

  既然文本串不会退缩。那么模式串就需要回退，只是不再从头开始了；模式串的回退规则是：**<u>要退到下标为m的地方，使得这个m之前的部分和上一轮中模式串错配的字符前面的那部分完全相同，既然后缀已经匹配成功过，意味着和后缀相同的前缀也没必要在本轮重复再比较了。</u>**，从而避免重复比较。

  因为每一个模式串的字符都有可能成为失配时的“案发现场”，所以需要为每一个**模式串**的字符构造一个值，这个值就是满足上面那个划线句子的最长的字符串长度。实际上，这个值叫做**最长相同前后缀字符串的长度**。这样来看就很好理解了。构造出来的数组叫做next数组。

* next数组：对于每一个next[j],指的是模式串[0到j的切片（**不包含j**）]的最长公共前后缀的长度。如aa，第一个a的next值就是0，第二个a也是0（因为对于第二个a来说，它前面的切片只有一个a，对于这个a这字符串，是不存在前后缀的）；

③根据上述理解构造next数组

=> 构造三部曲

* ①对j瘦身;  -- 找到使得patt[i-1] == patt[j]的那个j的值 为什么是i-1？由于next[i]指的是不包含patt[i]的、前面的字符串的最长公共前后缀的长度，所以**i-1才是后缀的游历变量**；=> 构造剩余位置，i才是快指针，即一直跑的那个前面的指针-后缀的指针，**j是前缀的指针**。
* ②判断是否匹配的上；
* ③给next赋值；

-- 有dp的味道，也有滑动窗口的味道；

④有了next再根据next进行正常匹配即可。

​	我们这种next的定义方式的好处是方便理解。现在KMP的核心就是好好理解理解构造next的三部曲。

```c++
class Solution {
public:
	int* getNext(const string & s) {
		int * next = new int[s.size()];
		// 初始化
		int j = 0;
		for(int i = 0;i < s.size();i++) {
			next[i] = 0;
		}
		for(int i = 2;i < s.size();i++) {
			// 瘦身
			while(j > 0 && s[i-1] != s[j]) {
				j = next[j];
			}
			// 判断是否匹配
			if(s[i-1] == s[j]) {
				j++;
			}
			next[i] = j;
		}
		return next;
	}
    int strStr(string haystack, string needle) {
        int* next = getNext(needle);
        int j = 0;
        for(int i = 0;i < haystack.size();i++) {
			while(j > 0 && haystack[i] != needle[j]) {
				j = next[j];
			}
			if(haystack[i] == needle[j]) {
				j++;
				if(j == needle.size()) {
					return i-j+1;
				}
			}
		}
		return -1;
    }
};
```

-- 初始化next就这样吧，不改了。

# 哈希表

-- python的dict很好用

18.有效的字母异位词（√）

​	我想说：Python的dict很顺手；此外，字母异位词，不异位也行，只要构成的字母一样，次数一样就行了；s和t相同也没事。

=================================2025.7.12====================================

19.两个数组的交集（√）

​	我想说：set去重，dic统计次数。

20.快乐数（√）

21.两数之和（√）

​	我想说：两层for循环和排序+双指针都可以过，只是双指针需要返回原来的下标，所以需要dic辅助。

22.四数相加II（√）

​	我想说：只看个数，是可以用乘法的；而不一定四层for循环暴力；而是分为两组，每组两个数组，计算两次并统计频率；然后看我这里的你那里有没有我的相反数，如果有，就乘起来累加到计数器中。

23.三数之和-♥ 、 四数之和-♥（待）

​	我想说：这个题不简单的；目前除了KMP，这个的难度是第二名。要涉及到去重。而且我自己的思路有问题，还是背人家的模板吧。 首先三数之和复杂度是O(n^2^)，四数之和类似。三数之和要涉及到结果不重复，关键是去重；而且还不能用set这种去重，因为涉及到ret中的每一个都是一个数组，数组是不可以用set去重的。

​	模板是固定第一个，双指针判断后面两个；而不是固定两个。而且还可以剪枝；通过三个数的和大于0来剪枝；上来肯定是对a去重的；bc通过双指针控制；b和c也要到时候去重；去重的时机是最关键的；由于我们是排序过的nums，然后第一次使用是不去重的。因为如果第一次使用前就先去重，会导致研究范围错误和结果情况的丢失。

# 队列栈

24.用栈实现队列（√）

25.用队列实现栈（√）

26.有效的括号（√）

​	我想说：在遍历到右括号的时候，不要直接访问top，而是先检查size是不是为0.

27.删除字符串中的所有相邻重复项（√）

​	我想说：CPP中的reverse函数是基于迭代器的，而且是原地反转。

```c++
reverse(ret.begin(),ret.end());
return ret;
```

28.逆波兰表达式求值（√）

​	我想说：思路不难，就是语法细节要注意。

教训:

* python中，判断一个str是不是数，不要用isdigit，isdigit可以判断是否是数字串，但是对于负数不可以；方法是try-except，即尝试int(str)这样转换。如果except说明不是数；
* **不同符号的整数作整除，-1/2的结果是-1，而不是0；所以正确的姿势是符号和绝对值分开算；**

```python
# 除法应该这样写
sym = 1
if op1*op2<0:
    sym = -1
    st.append(int(math.fabs(op1) / math.fabs(op2) * sym))
```

29.滑动窗口最大值-♥-单调队列（待）

30.前k个高频元素-♥

​	分析：我看了思路，最容易想出来的其实是全排序，然后取前k个，这样不是最优的算法时间，是O(nlogn),即主要是全排序的复杂度；如果维护一个大小为k的小根堆，这样的复杂度可以降低到O(nlogk);

​	维护一个大小为k的小根堆很关键，外层for循环面向统计频率后的key的集合，是O(n)的；内层小根堆里面维护频率最大的k个元素，如果满k个了再加入新的进来，我就需要把堆中堆顶pop出去使得堆中一直有k个，当然刚才被pop出去的也可能是新加进来的，这个我不关心。

-- 重点关注小根堆的定义的语法和自定义仿函数的语法；这块不太熟悉。

```c++
class Cmp{
public:
	bool operator()(pair<int,int>&p1,pair<int,int>&p2) {
		return p1.second >= p2.second;
	}
};
class Solution {
public:
	
    vector<int> topKFrequent(vector<int>& nums, int k) {
        // 统计频率
        map<int,int> mp;
        for(int n:nums) {
			mp[n]++;
		}
		priority_queue<pair<int,int>,vector<pair<int,int>>,Cmp> pq;
		for(pair<int,int> p:mp) {
			pq.push(p);
			if(pq.size() > k) {
				pq.pop();
			}
		}
		vector<int> vec;
		while(pq.size()) {
			vec.push_back(pq.top().first);
			pq.pop();
		}
		return vec;	
    }
};
```

31.二叉树的先序遍历-非递归

​	我想说：这里很关键的就是要判空，如果是空，不必入栈，root如果是空也不必继续了；再就是重视一下左右孩子的入栈顺序。

32.二叉树的后序遍历-非递归♥-需要强化思路

​	思路：后序和先序是近似相反的；我们知道，改变左右孩子入栈的顺序可以改变左右孩子的遍历顺序；先序是中左右；而后序是左右中；假设直接把先序进行reverse，得到的是右左中，和后序不一样；所以需要先在先序的过程中改变左右孩子的遍历顺序，然后最后逆序，即可得到后序的遍历。

​	注意，先序和后序是不涉及指针移动的，完全是根据栈这种数据结构的操作来实现的。

33.二叉树的中序遍历-非递归♥-需要强化思路

​	思路：左右中，第一个便利的肯定是最左侧那个，所以需要一路向左，然后一边走一边入栈保存记录方便回退；一直到左孩子为null，就可以访问根了，然后尝试往右走，继续一路向左。整体思路就是这样。也不是很难想到。但是很久不写就容易忘记思路。

​	教训：这个题必须**以身入局**，否则左孩子遍历完之后，根更新为上面的根之后还会继续判断左孩子，从而陷入死循环的重复遍历左孩子的过程。所以为了避免重复遍历，就必须以身入局。

​	以身入局，很显然就不能在一开始就入栈，因为你在循环中是一定需要判断自己是否为空的，而在循环外面你是不知道自己是不是为空的，所以while的条件就不能只是栈判空，而需要加上root的条件，满足其一即可。

```c++
class Solution {
public:
    vector<int> inorderTraversal(TreeNode* root) {
        stack<TreeNode*> st;
        vector<int> vec;
		while(root || st.size()) {
			if(root) {
				st.push(root);
				root = root->left;
			}else {
				TreeNode* temp = st.top();
				vec.push_back(temp->val);
				st.pop();
				root = temp->right;
			} 
		}
		return vec;
    }
};
```

# 二叉树

-- 争取一天搞定

34.二叉树的先序、中序、后序遍历-递归（√）

=================================2025.7.13====================================

35.二叉树层序遍历（√）

​	思路上，有两个难点：一个是我们要对结果分层，一层放入一个vector，那如何界定每一层之间的分隔呢？答案就是用for循环，while的内层每一轮面向的是一层，而结果不分层的那种每一轮while面向的是一个结点。所以while的一轮需要处理一层，就需要用for循环，循环数是进入while的时候的队列大小，意思是当前处理的层的结点数。这样就可以运行指定的轮数，把这一层都处理掉，每一层for的内部访问之后分别让左右孩子入队列。

​	第二个细节要注意的是for循环的范围不能用q.size，因为q.size随时伴随着入队情况在变化；只有for循环的范围是一个确定的常数范围，才可以处理树的一层。

36.二叉树层序遍历2（√）

37.二叉树的右视图（√）

​	我想说：你可以层序遍历之后再对ret处理，也可在层序遍历过程中只选择每一层最后那个放入结果集rv.

38.二叉树的层平均值（√）

39.N叉树的层序遍历（√）

40.在每个树行中找最大值（√）

​	注意：C++中的最大INT和最小INT分别是INT_MAX和INT_MIN；需要包含头   `<limits.h>`.

41.填充每一个节点的下一个右侧节点指针（√）

42.填充每一个节点的下一个右侧节点指针2（√）

​	我想说：和41一模一样，代码不变；不管是不是完全二叉树，代码都是一样的，是通用的思路。

43.二叉树的最大深度（√）

44.二叉树的最小深度（√）

​	我想说：最小深度其实就是看叶子最早出现在那一层决定的。注意最小深度的定义是从根到最近的叶子的路径的节点数；     **我开始理解错了**，不是到最近NULL，而是最近叶子。挺简单的，遍历节点的时候就判断一下是不是叶子，返回第一个叶子的层数即可。

45.翻转二叉树（√）

46.对称二叉树（√）

​	我想说：之前我不会这个，但是现在我一气呵成了；其实就是判断左右子树是不是可翻转的，需要一个传入两棵树的isReversable函数；当且仅当两棵树的树根等值并且对应位置的两棵树也可翻转才是可翻转的两棵树。

47.完全二叉树的节点个数（√）

​	法1（最高效的）：先序遍历的过程中让num++，但是没有利用完全二叉树这一个特性。

```c++
class Solution {
public:
	void preOrderTraversal(int&num, TreeNode*root) {
		if(!root) {
			return;
		}
		num++;
		preOrderTraversal(num,root->left);
		preOrderTraversal(num,root->right);
	}
    int countNodes(TreeNode* root) {
        int num = 0;
        preOrderTraversal(num,root);
        return num;
    }
};
```

​	法2（最高效的）：直接层序遍历，但是没有利用完全二叉树这一个特性。

​	法3♥：如果要利用完全二叉树的特性，我们可以根据深度计算一棵满二叉树的节点数量；**可以利用递归不断递归下去一直到root是一棵满二叉树我们才计算其大小。**。我们做的只是计算深度，然后判断一棵树是不是满二叉树，判断方法是左子树和右子树的最大深度一样，而且左右子树都是满二叉树。

​	所以思路很明确了，需要两个辅助函数，一个是求最大深度，一个是判断是不是满二叉树。但是由于递归次数太多，因此时间效率并不快。

```c++
class Solution {
public:
	int getNodeNum(int c) {
		return int(pow(2,c)) - 1;
	}
	int getMaxDepth(TreeNode* root) {
		if(!root) {
			return 0;
		}
		return max(getMaxDepth(root->left),getMaxDepth(root->right)) + 1;
	}
	bool isFullBinaryTree(TreeNode*root) {
		if(!root) {
			return true;
		}
		return getMaxDepth(root->left) == getMaxDepth(root->right) 
			&& isFullBinaryTree(root->left) 
			&& isFullBinaryTree(root->right);
	}
    int countNodes(TreeNode* root) {
    	if(!root) {
			return 0;
		}
        if(isFullBinaryTree(root)) {
			return getNodeNum(getMaxDepth(root));
		}
		return countNodes(root->left) + countNodes(root->right) + 1;
    }
};
```

48.平衡二叉树（√）

===================================7.14========================================

49.左叶子之和（√）

​	我想说：不要漏掉任何一种情况，考虑全面。

50.找树左下角的值（√）

​	我想说：模版题。

51.从中序和后序序列构造二叉树（√）

52.从前序和中序序列构造二叉树（√）

​	=> 51 and 52 我想说：直接ac，但是难点在于下标的计算。

53.最大二叉树（√）

54.合并二叉树（√）

​	我想说：直接ac，要注意不需要new任何node，改一改指针，合并到root1上即可。

55.路径总和（√）

​	我想说：可以回溯暴力，但是也可以有更简洁的写法-整体来说这个题目很简单，直接oc。

56.二叉搜索树中的搜索（√）

57.验证二叉树（√）

​	我想说：这个宁愿多分点情况，递归出口多搞几个，单独有左孩子或者右孩子的要分开算，因为他们的return的逻辑不能和别的合并起来。

58.二叉搜索树的最小绝对差（√）

​	我想说：这个可以实现O(n)，即中序遍历bst得到升序序列，然后求gap的min即可。

59.二叉搜索树中的众数（√）

60.二叉树的最近公共祖先（√）

​	我想说：找到所有祖先-isContained函数，然后把所有满足的都放入一个容器，用层序遍历的方式遍历；就可以找到最近的。

61.二叉搜索树的最近公共祖先（√）

​	我想说：保研能ac就行，用通式通法就行-**<u>可以利用bst优化</u>**。

62.二叉搜索树中的插入操作（√）

​	我想说：其实这个应该挺简单的，就用这个函数递归即可；递归出口就是为空的时候返回一个new Node；关键是处理好往哪边插入，就需要递归哪边，把root的孩子和递归联系起来；还有一个很关键的地方在于，bst中默认不允许有重复的，有重复的则规定不会插入的；所以这个题目默认不会重复。体会一下代码：

```c++
class Solution {
public:
    TreeNode* insertIntoBST(TreeNode* root, int val) {
        // 先找到插入位置
    	if(!root) {
			return new TreeNode(val);
		}
		// 判断
		if(root->val > val) {
			// 左侧
			root->left = insertIntoBST(root->left, val);
		}else {
			// 右侧
			root->right = insertIntoBST(root->right, val);	
		}
		return root;
	}
};
```

63.二叉树的所有路径（√）【回溯算法】

================================7.15================================

64.删除二叉搜索树中的节点（√）

​	我想说:审清楚题，看看题干是否保证key一定在树中，如果不保证，肯定要作递归的出口；第二个要注意的地方是，删除root这个结点，的时候无需手动找到父亲然后把父亲的指针置空，因为父子的连接是依赖于return来连接的，在单层逻辑的地方就会处理这些。

================================7.17================================

65.修剪二叉搜索树（√）

​	我想说：这个题特别简单，不要认为很难，也不需要调用deleteNode函数，只要你想想bst的特性，就会很容易写出来。

66.将有序数组转换为二叉搜索树（√）

67.把二叉搜索树转换为累加树-❤

​	这个题我有好几处不太理解所以导致错误：①没有搞清楚什么是累加树-累加树是把bst的每一个node->val修改为整棵树中>=自己的val的值之和的一棵树； ②处理逻辑错误：不管是错误1-上来就计算自己和自己的右子树的和作为node->val还是错误2-整棵树的总和-左子树，都是偏见，都是锚定了一种特殊情况就写代码导致漏情况的偏见。

​	而且就算综合起来，你也要分情况讨论，复杂度极高；应该利用bst的特点，中序遍历是升序序列；即左往右遍历就会从小到大遍历；而且考虑到会一边遍历一边修改，如果采用中序，则会导致原树的值变化-根本原因是整棵树的一些节点会被重复不断地访问。所以应该逆中序遍历；保证整棵树只遍历一次，而且维护一个全局变量累加即可。代码实现还是很简单的，难点在于思路。

