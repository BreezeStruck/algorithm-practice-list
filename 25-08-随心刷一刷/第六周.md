==============8.13==============

1.【167】两数之和II - 输入有序数组

​	分析：输入为有序是数组，就可以考虑双指针了，如果加起来大于target，就让两个数小点-只能让j--，否则i++，如果等于target就可以返回结果了。

​	由于无需sort了，所以O（n）即解决。

​	 注意事项是：下标从1开始，最后构造到时候别忘了分别+1.

2.【2105】给植物浇水II

​	分析：两个人有一个容量不一样的水桶，A从数组的左侧开始浇水，B从数组的右侧开始浇水，只有当桶中的剩余容量 >= nums[i]的时候，A才可以浇水，B同理，否则需要先灌满一次水，当两个人最后只剩下一朵花需要浇水的时候，不管够不够，谁的水剩下的多谁浇水。给定nums和两个桶的容量，求总共的重新灌满水的次数。

​	直接双指针**<u>模拟</u>**就好。

3.【1471】数组中的k个最强值

​	分析：给我一个arr和一个k，找k个最强值构成的列表，最强值指的是如果两个数，谁距离中位数m更远，或者一样远，谁的值大谁就更强。返回的顺序不限。模拟就好了。

​	说中位数，前提是有序。所以先sort一下升序，然后就看谁离着这个数远，所以相向双指针，从两端最远的地方开始遍历就行了。复杂度是O(nlogn)。简单题目。

​	这沙沟题目，**中位数的定义都要修改**，诶，算了不说了。**以后每个条件多蒻都要看一看，审一审。**

4.【658】找到K个最接近的元素 - 难点

​	分析：arr是排序好的数组，给我整数k和x，约好求我找到最靠近x的k个数，结果也是升序排序好的。a比b更近的意思是：距离更短，距离相同则较小的数更靠近。

​	本题我自己写超时了。看了题解，觉得自己还不足。①思路：本质上是求一个长度为k的区间。所以我们可以从两侧开始双指针，排除两侧的元素，一直到区间的长度为k，就可以break构造结果了，无需额外的排序。 ②**求两个数之间的距离**：就是相减再绝对值。比如-4和2的距离，-4-2的绝对值也没问题，举个数，不要想复杂了。

​	我的思路的问题：顺序查找到离着x最近的两个数，然后往外扩展，这样很麻烦-而且超时，必须二分查找优化。可以逆向思维，面向结果想，就是上面的思路。

​	**反思**：如果左侧的距离更远，那么我就淘汰它，即i++；否则j--（涵盖了等距的情况，等距肯定算左侧的i更近的，要保留i舍弃j的）。

5.【633】平方数之和

​	分析：判断是否存在就ok，C可能为0，所以0也要看，假设a = 0，b的上限是根号c向下取整。所以只需要双指针就好了，和两数之和类似，i从0开始，j从根号c开始。

反思

* 涉及大数据，都用long long，强转的时候，long long用括号括起来；
* 提交之前，顺一遍，看看有没有低级错误。

6.【2824】统计和小于目标的下标对数目

​	分析：给我一个nums和一个target，要求所有坐标对的数目，坐标对i，j的值加起来小于target。

​	可以先排个序，方便用双指针，数据量不大，一定可以ac的。还是类似于两数之和，如果加起来小于target，证明这个时候j ∈ [i+1,j]都是可以的，我们直接统计一波，这个时候i需要++；否则说明>=target,则通过j--往小里走。不需要找什么临界状态。	

7.【LCP 28】采购方案

​	分析：类似于2824，这个题是不超过。注意ans需要取模，根据题目的要求做就好了，然后ans用long long即可。

8.【2563】统计公平数对的数目

​	分析：本题也是统计数对的数目，只是要求对应的值之和落在一个闭区间范围内才算。也是一样的，双指针就好了。分三种情况。

​	一般的思路超时了，就是找到一个合适的，然后定i，再次遍历中间的j，然后累加，这样太麻烦了。

​	既然是闭区间，就可以改为两个“最多型”的差值，假设一个最多型是上面的LCP 28的不超过，那只需要返回count(upper) - count(lower-1)即可了。

9.【15】三数之和

​	分析：本题我ac过，但是之前对双指针的理解不深刻，现在重新提交一下。

​	反思：去重的逻辑，在符合下标约束的前提下，如果本次和上次一样，索引就++或者--，但是如果去重完毕之后索引越界了，就可以直接break了。

10.【18】四数之和

​	分析：和三数之和的注意事项是一样的，多套一层枚举。

注意事项：

* 去重是while，而不是if，要检查清楚。提交之前都要检查清楚。
* 第一轮不要去重，就想我们是比较num[i-1] 和 nums[i]的大小关系的，所以i = 0不需要去重，类似的，如果j初始化为i+1，那么j=i+1的时候也不需要去重。

==================8.14==================

1.【16】最接近的三数之和

​	分析：和三数之和是类似的，但是好在不需要去重也可以，因为需要的是sum离着target最近的sum。O(n^2^)遍历就好了。遍历的过程中维护sum和min-最小间距。

* 写之前一定要搞清楚条件，前后关系，来龙去脉，争取一次就ac不要一直运行然后再改。

2.【611】有效的三角形的个数 - 难点

​	分析：可以排序之后然后双指针，但是三角形的三边满足两边之和大于第三边，两边之差小于第三边。如果我们可以先确定最长的边，就只需要利用一个条件进行处理了。即枚举最长边 + 两数之和的套路。

​	因为我只需要找到两个数之和大于第三边，然后我就一定可以确定 i 和 j 之间的i都可以用（为什么这么想？因为此时nums[i] + nums[j] > nums[k]， 指针的移动应该是j--让之和小一点，所以我们统计增量的时候应该让j定住，i变化来统计增量，这个增量的大小是j-i的长度个i）。 

​	反思：本题我的错误在于枚举了最短边，然后同时考虑两个条件，其实是没有必要的，因为是有序的，你枚举最短边，还用两边之和大于第三边，那是纯纯有病，因为恒成立，只需要考虑两边之差小于第三边。所以脑子很重要，我们采用枚举最长边的思路。

3.【1577】数的平方等于两数乘积的方法 - 太难了

​	分析：写一个工具函数，我们用一个数组做平方，一个双指针查询。如果乘积大于平方和，k--，如果小于平方和则j++；难点是相等的时候，题解里面说了两种情况，即如果j和k之间的数都相等，即nums[j] == nums[k]，由于是有序的，说明之间的都相等，那就组合任取两个数都是可以的，就可以用C~x~^2^的公式来计算，否则就分别统计两侧连续相等的，然后乘起来即可。

​	很容易卡在这个target == multi的情况。

4.【923】多重三数之和

​	分析：本题是【1577】的变式题，一模一样的思想。

5.【948】令牌放置

​	分析：观察样例之后发现，不是每一个令牌一定要使用的，如果两种策略都不行，那显然直接跳过这个令牌就好了。根据样例3，我们不难想到，我们可以先对令牌排序，先用左侧的令牌花费能量获得分数，然后再用右侧的令花费1分获得大量能量，这样有利于我们获得更多的能量。

注意事项：

* 内部应该先尝试花光所有的能量获得更多的分数（前提是保证i<=j，即内部要随时检查保障不越界访问）；然后尝试购买一次能量，不要一次性买多了，我们要让更多的令牌用来获得更多分数。
* 由于最后退出的时候可能会多花一次分数购买能量，所以我们维护中间分数的最大值来返回。
* 循环内部一部分是尝试购买分数，退出意味着能量花没了，如果第二部分检查的时候发现分数也没了，那证明就可以返回结果了。

6.【1616】分割两个字符串得到回文串

​	分析：如果暴力，判断回文是O(n)，遍历分割的位置是O(n)，整体O（n^2^）,会超时。

​	回文最长用的操作是根据回文的性质进行双指针。我们可以直接一层双指针，同时判断两个部分，最后相遇的地方就是切割的地方，而没有必要单独遍历切割位置。

​	果然我第一次就ac了，我们可以写一个check函数，然后返回`   check(a,b)||check(b,a);` 即可。我们的核心就是找到a的前缀和b的后缀能否构成回文。如果一旦不相等，就转移到一条相同的字符串（可能是a，可能是b）上完成剩下的任务。

=======分组滑窗（个人原创模版）======

7.【1446】连续字符

​	分析：子数组问题，可以滑窗。ac了，100%。

```cpp
class Solution {
public:
    int maxPower(string s) {
        int left = 0, ans = 0;
        s.push_back('A');  // 虚拟节点-不出现在s中的都可以，可以避免最后一组单独处理
        for(int i = 0;i < s.size();i++) {
        	if(s[left] != s[i]) {
				ans = max(ans, i-left);
				left = i;
			}
		}
		return ans;
    }
};
```

8.【1869】哪种连续字符串更长

​	分析：子数组问题，可以滑窗，ac了。为了处理最后一组没人更新的问题，我们手动插入一个虚拟的字符‘2’，这样就可以更新了。

​	如果当前的和left对应字符不一样，我们就收集这一组（这一段）。欣赏一下我的code,也可以把1446的代码优化一下。图上所示↑

```c++
class Solution {
public:
    bool checkZeroOnes(string s) {
        int left = 0;
        s.push_back('2');
        int ans_1 = 0, ans_0 = 0;
        for(int i = 0;i < s.size();i++) {
        	if(s[i] != s[left]) {
				if(s[left] == '1') {
					ans_1 = max(ans_1, i - left);
				}else {
					ans_0 = max(ans_0, i - left);
				}
				left = i;
			}
		}
		return ans_1 > ans_0;
    }
};
```

​	=> 反思：上面的写法是双指针还是滑动窗口？  其实我们没有必要区分那么细，严格来说应该是**<u>滑窗的思想</u>**解决子数组的问题，但是缺乏了经典的显式的右侧入窗口，以及while尝试根据条件循环更新left的部分，所以说是同向双指针也不为过。如果严格按照滑窗也可以些，但是优化写法之后就是上面的，很多操作我们无需做。

​	插入虚拟节点来统一最后一组的写法也很经典。

​	【1446】和本题【1869】都属于多段连续相同子数组的拼接版本 - 即灵神的分组循环双指针问题。我都觉得应该用滑窗的思想去思考，多去考虑一下什么时候需要更新left的问题。按照滑窗的思考角度思考就好了-cnt按理来说是需要的，但是有left和i，就足以计算长度了。

9.【2414】最长的字母序连续子串的长度

​	分析：是一样的，和分组相等的字符串类似，判断条件只需要改为if(s[i] - s[left] != i - left),就说明不连续了。最后也需要插入虚节点。

10.【3456】找出长度为K的特殊子字符串

​	分析：本题的题意是在字符串s中找到一个长度为k的子串，该子串由同一字符构成，而且子串的前后都不同于该字符。判断是否存在。

​	我们只要看到这种一样的字符或者字符之间有某种规律的，都可以上面的分组的滑窗模版。就是当right指向的和left不符合规律的时候，就可以收集信息/尝试更新了。

​	本题不一样的地方是：要求前后都不一样，考虑特殊情况，如果答案出现在最左侧，那么这也是符合的，我们默认最最左侧存在一个不一样的字符就好了。我们仍然需要用虚节点。

11.【1957】删除字符串使字符串变好

​	分析：也可以套模板，只是在处理的时候，我们拼接字符串，如果长度大于2，证明需要删除，但是我们只需要拼接两个该字符就好了。

// `7,8,9,10,11`这几个题都一样。

12.【674】最长连续递增序列

​	分析：说是子序列，但是你看题的描述就知道其实是子数组，最长连续递增的子数组可以dp来写，也是O(n)的，但是子数组我们更倾向用滑窗,所以我们再写一遍滑窗的写法。

​	找到递增的子数组，一旦不满足就重新开始，这相当于把本来的一个arr分为若干个严格单调递增搞得子数组，找到最长的那一段的长度。维护一个max_len即可。

反思：

​	略有不同，但是差别不大。别忘了最后的时候插入一个辅助节点-INT_MIN。

13.【978】最长湍流子数组

​	分析：需要保证子数组的元素之间的不等号不断翻转，要么是 < > < > < .... 要么是 > < > < ....  我们需要用一个pre记住上一组的不等号方向，要么是0代表小于，1代表大于，2代表非法即其它。

​	当遇到非法的时候（很容易得到两种合法的情况），就可以开始收集了，并且更新新的开始。 循环最开始的时候，先处理pre是否为2，如果为2，说明是新的开始（如果说题目是分组循环的话，这就是新的循环的开始），如果不为2，说明循环中。然后如果是2，就需要判断关系并且更新pre为下面准备，或者可能继续是2.

​	在循环中，判断当前新加入窗口的元素和之前的元素的大小关系和pre 的关系得到非法的情况，非法情况时，pre的更新和left的更新尤为重要。当arr[i] == ar[i-1] 和arr[i] ！= ar[i-1]时，两个变量的更新策略是不一样的。如果合法，那就简单了，只需要pre由1变0或者0变1即可。

​	整体还是思考：遇到什么条件我就可以收集了？这是核心的问题。对了，虚拟的尾节点也是需要插入的-插入一个和最后一个元素相同的元素即可。

14.【2110】股票平滑下跌阶段的数目

​	分析：一个阶段可以看做一个子数组，求的是平滑下降子数组的数目。看了样例我明白了，我们可以寻找所有的平滑下降阶段，然后收集他们的长度。每一个阶段的“子串”都属于结果的一部分-用连续n个的子集数 - “梯形面积公式” - **n * (n + 1) / 2**计算即可算出来结果的一部分，所有的长度都这样算，最后求和即可。本质上还是上面的滑窗的模版思路。

​	也可以收集的时候直接让ans  += 长度（i-left）对应的“梯形面积”。

15.【228】汇总区间

​	分析：也是 一样的，按照相邻元素递增1分组，其实还是模板题目，最后按照要求构造ret即可。

* 注意我用到了INT_MIN作为虚拟节点，所以还需要用(long long)强转一下其中一个int，否则减法之后会溢出int。

16.【2760】最长奇偶子数组

​	分析：本题也是分组循环的滑窗，要求是子数组内的所有的数不超过阈值；而且第一个数是偶数，后面奇偶性交替。

​	所以我们收集的条件是：当遇到了一个大于阈值的数，或者奇偶性和当前窗口的一样的时候。其它就是模版。虚节点插入一个1或者0-取决于最后一个数的奇偶性，和它一样即可。

反思：

​	本题的难点在于left的初始化以及更新，都需要满足找到一个地方 - 使得低于阈值，而且left的位置必须是偶数。不过经过思考我也ac了。

=============8.15============

-- 继续分组循环

1.【1887】使数组元素相等的减少操作次数

​	分析：本题看上去复杂，经过样例模拟之后发现，只需要排序之后，相邻相等元素为一组，操作的过程本质上就是大数组个数不断变为小数的过程，如1 3 5 就是 1+2 = 3，就是5变3然后两个3变为1。所以我需要做的就是统计个数。将数组**<u>先逆序排序</u>**。然后统计每组的个数，用一个变量r记录下一次需要加多少个，r = r + (i-left)，（r初始化为0）然后ans +=r 即可。最后一组无需插入，所以无需辅助虚节点。

2.【845】数组中的最长山脉

​	分析：上坡的时候正常处理，下坡的时候更新，用一个up标记表示在上坡还是下坡，上坡1下坡0.因为上坡改下坡一定是至少存在了两个元素了，然后遇到下一个数比窗口内的最右侧元素更小，所以满足最少三个元素。

​	如果遇到非法情况，如等于的情况，则从当下开始更新left。当然最后我也要收集，所以需要插入和最后一个元素等大的元素来收集。收集的前提是下坡，即标记为0，如果标记为1，则不处理。非法的标记是2.

3.【2038】如果相邻两个颜色均相同则删除当前颜色

​	分析：本题可以看做是至少连续长度为3的子数组作为一组进行删除中间的元素。看看A和B满足条件的子数组谁更多的问题。Alice和Bob的删除是互不干扰的，可以把整个字符串看做连续的A和连续的B交错拼接而成。因为即使有多个连续的A，也不会删除干净，最多留下两个相同元素，这两个相同元素也会有隔离的效果。

​	所以我可以分组循环统计连续字符的个数，然后分别统计Alice 和Bob能删除的次数，谁的删除次数多，谁就赢得比赛。比如当前滑窗遍历的某段是AAAAB，遇到B的时候，就可以收集Alice可以删除的次数了（前提是长度4>=3），cnt_A += 2即可。B的统计是类似的。

4.【2900】最长相邻不相等子序列I

​	分析：本题看着复杂，其实words就是一个结果映射数组，主要看groups，其实就是选最长的交错0101子序列的长度，本质是去重，这样我们就可以把连续的1或0看做一组，每一组我们随机选一个-就设定最左侧的索引为我们需要的索引--题目中说多个答案返回1种即可。然后用这个idx去words中映射拼接结果集即可。

​	还是分组循环滑窗的模版题。

5.【1759】统计同质子字符串的数目

​	分析：本题和我昨天做的梯形面积【2110】-股票平滑下跌，那个很类似，本质还是分组-每组是相同字符构成的子串，然后根据这一组的数目，根据梯形公式求一下子串的个数，求和即可。

反思：

* 别忘了中间计算梯形面积的时候的中间乘法结果也需要用long long暂存。

6.【3011】判断一个数组是否可以变为有序

​	分析：并不难，是我傻了。题目中说相邻的二进制中1的个数一样的两个数才可以交换。那没事了。注意，最后一组不需要单独收集，所以不需要虚结点辅助。

7.【342】4的幂

​	分析：每日一题，4的幂。挺简单的，就是先写一坨屎，然后合并代码，优化。整体思路是把大的数映射到[0,3]范围内。判断最后是不是1即可。当然有些比如20，映射不到就不是4的倍数了，那就在循环内return即可。

8.【1578】使绳子变成彩色的最短时间

​	分析：本质是去重，但是相同的气球删除花费的时间不一样，所以需要保留一个时间最长的，所以我们可以在分组循环的过程中，收集总时间，然后管理最大时间，最后统计的时候删除最大时间即可。

9.【1839】所有元音按顺序排布的最长子字符串

​	分析：也是分组滑窗，当遇到了顺序不一样的地方就结束分组了，条件是    `if(word[i] < word[i-1])`；需要虚拟的头结点，所以我们需要尾巴插入一个大写字母即可。

10.【2765】最长交替子数组

​	分析：本题有点难度，条件很复杂，所以需要写一个check函数。然后更新ans的时候也需要满足条件。

11.【3255】长度为K的子数组的能量II

​	分析：本题不是定长滑动窗口。而是要尽量找到连续的步长为1的递增子数组，根据这个分组。一旦发现不满足条件就开始尝试收集，只有子数组长度>=k才可以更新ret数组。否则不更新。ret初始化为全-1即可。

​	复杂的地方在于如何更新，下标需要择清楚。

12.【3350】检测相邻递增子数组II - 有点难度

​	分析：需要找到若干段严格单调递增的子数组，我们需要找到相邻两个子数组且等长为k，求k的最大值。宏观来看，整个nums确实是由若干段单调递增的子数组构成的，我们可以滑窗找到他们然后分组，确定他们各自的长度。最后检索相邻两段子数组的长度是否相等，然后维护一个最大值。

​	我们也可以在滑动的过程中维护一个最大值。比较当前的长度和上一次的长度是否相等，让pre_len初始化为0。这样让代码更简单，因为相邻两段的首尾一定是相邻的，所以可行。

反思：

* 看完样例我才知道，一个连续的最长单调递增的子数组可以划分出两段等长的单调递增的，结果也可能产生于此。
* 我们最开始的思路是尽量让每一段尽量长，然后比较相邻两段的长度是否等长，然后更新ans；但是如果两段之间也满足递增关系，就会形成一个更大的段，显然答案也可能是这一大段中的两个子段。
* 所以我们整体的思路就是先让每一段尽量大，维护一个pre_len和一个当前的i-left长度，比较两段并更新。我们取二者的最小值，并和ans取max。因为即使二者不等长，我也可以取长的一部分出来。并维护最长的一段这个变量，方便最后单独将最长的一分为二再和ans求max。

13.【3105】最长的严格递增或递减子数组

​	分析：求最长严格单增或严格单减的子数组的长度。 就是分组，当单调性发生变化的时候或者相等的时候就开始收集上一段的信息。我们需要用一个标记变量up来记录之前的状态是上升沿（1）还是下降沿（0）还是相等/最开始，即非法状态（2）；不同的状态将影响我们对窗口左边界left的更新以及对标记变量up的更新，以及影响我们是否需要更新ans。

​	整体的框架是比较当前打算新加入窗口的值和窗口的上一个值的关系。

================8.15=================

1.【135】分发糖果

​	分析：【写过本题了】之前是贪心 + 前后分解，现在用贪心 + 分组滑窗。由此看出，只要涉及到循环的规律的，这里的循环规律是单调性是循环的，一个上升然后下降，类比于一座山，就是一个循环节。循环节构成整体，一个分组滑窗管理一个循环节。

​	对于一座山，从左往右侧看的上坡，根据贪心，我们让最左侧为0个糖果（我们假设先给每个孩子一个糖果，满足最基本的条件，后序就不考虑了），然后依次递增，顶峰先不管。下坡也是一样的，我们希望给下坡的波谷0个糖果，然后往左依次递增，然后顶峰应该比两侧都多，所以取两侧的最大值+1.

​	然后每一座山峰都这样构造。一座山峰的糖果数 = 三部分之和，只需要知道上坡和下坡的数量（不包含顶峰），就可以算出来总糖果数。邻接可以作为本次下坡的结束，也可以作为下次上坡的开始，都不影响。

​	牛逼，直接ac，用标记处理这种单调性的。up = 1表示上坡，2表示非法或者刚开始或相等，0表示下坡。

2.【1323】6和9组成的最大数字

​	分析：每日一题。一个由6和9构成的整数，只能翻转最多一次，6变9或者9变6，很显然我尽量让高位9变6即可。从高位到低位循环就好了。如果有就尝试翻转然后break。我不可能让9变6的。

3.【838】推多米诺 - 不会，看题解

​	分析：看了灵神的题解，本题需要分组循环滑窗实现，有四种情况，分别是L...R, R...L, R...R, L...L 后面两种情况就需要全部把中间的点改为R或L；第一种情况不变；第二种情况需要对称的修改，然后判断中间点的个数，中间的点不变。按照这样的结构分组。

​	关键是什么时候收集，当遇到不是点的时候就需要处理了。而且为了方便处理两侧的情况，需要添加虚节点，即哨兵。左侧添加一个L，右侧添加一个R即可。

​	**<u>学习</u>**：fill函数，传入迭代器区间，第三个参数是填充的元素。可以快速实现置数。

4.【467】环绕字符串中唯一的子字符串 - 不会，看题解

​	分析：看了一个大神的Go的滑窗代码，顿悟了。由于base是26字母顺序构成的无线拼接的字符串，所以以每一个字母开头的base都知道，我们无需用hash记录s的每一个子串以及出现的频率，那样太麻烦 - 用一个长度为26的hash记录以当前字母打头的、出现在base中的最长子串的长度。

​	子数组个数问题如何滑动窗口：由于base是连续的，可以把a和z看做是连续的，所以我们需要按照s的连续进行分组。一旦遇到不连续，就需要收集。由于窗口内是连续的，所以循环更新，让left从窗口最左侧遍历到窗口最右侧，让它尝试更新以s[left]打头的hash中的最大长度和当前的窗口（**【left,i）**)的最大长度的关系，如果不如原来的大，就无需更新。否则需要更新hash，并且需要更新ans，二者前后的增量差值就是ans的增量。意味着以s[left]打头的子串又增加了`i - left - cnt[s[left]]`这么多。

​	这题给我最大的启发是用英文字母打头的方式管理子串的最值，通过  `新的最大值 - 旧最大值`获得答案的增量来计算子串的数量。

​	**注意：收集的时候，需要循环，让left一点一点往右走，而不是直接更新为left = i，这也是这一题和之前的题目不一样的地方。**

5.【3499】操作后最大活跃区段数I

​	分析：本题给你一个二进制串，需要先插入辅助节点，首尾各插入一个1.用来确保恒有操作的第二步可以发生。操作最多进行一次，分为两个步骤：①找到类似于0111...1110这样的结构，将中间的1全部翻转为0；②找到1000...1这样的结构，将中间的0全部翻转。假设第一步反转后的连续0又发生了第二步，整个s中1的个数相当于增加了两段连续0的个数，而中间的连续1经过第一步和第二步的翻转，又回到了1，相当于什么都没变。

​	所以本题转换为寻找两个相邻的连续的0的子数组，如00011110011这里的00，使得加起来个数达到最大值。不难想到我们可以先分组统计连续同种类字符构成的子数组的个数，然后遍历他们，找到这样的最大值。

​	别忘了单独判断不合法的情况。 由于最后一段是需要统计的，所以需要插入哨兵2（其它的也行）

6.【413】等差数列划分

​	分析：我唯一担心的是是否需要字面量去重， 没说不同，那位置不同也算不同吧，试试。找到最长的就好，然后增量ans。这样分组处理。需要维护一个差距b。这么看这个题不太难。

​	哨兵的添加需要注意，一定要确保哨兵和前面一段不是等差数列对于所有样例都适用。不能简单地复制最后一个元素，因为最后一组的公差可能是0。所以需要push这个`nums[n-1] + (nums[n-1] - nums[n-2]) + 1`即可确保。

7.【26】删除有序数组中的重复项

​	分析：和【27】移除元素、【283】移动零一样。都是需要快慢指针的，快指针遍历的时候一旦发现nums[i] == nums[i-1]就不处理，否则是第一次出现，应该赋值到slow那里，最后返回slow即可。注意slow的初始化和for开始遍历的起始索引就好。

8.【80】删除有序数组中的重复项II

​	分析：不是完全去重了，而是让出现次数超过2的，删除多余的，使得出现2次。可以维护一个连续出现的次数变量，一旦发现次数大于等于2，然后又相等了，那就需要删除了。取非就是不需要删除的地方。

9.【905】按奇偶排序数组

​	分析：还是快慢指针的思路，不过我们需要一个寄存器寄存一下奇数用来最后修改尾巴。所以空间复杂度并不是O(1)的。这是单向的双指针，需要辅助数组。 代码如下。

```c++
class Solution {
public:
    vector<int> sortArrayByParity(vector<int>& nums) {
        int slow = 0;
        vector<int> rst; // 奇数寄存器
        for(int i = 0;i < nums.size();i++) {
			if(nums[i] % 2 == 0) {
				nums[slow++] = nums[i];
			}else {
				rst.push_back(nums[i]);
			}
		}
		for(int i = 0;i < rst.size();i++) {
			nums[slow++] = rst[i];
		}
		return nums;
    }
};
```

​	优化：如果采用相向双指针，则可以优化空间复杂度为O(1)，具体思路是采用交换的思路。如果i指向的是偶数，i就++；else if j指向的是奇数j就--；否则就说明二者都指向了和自己管理的那一半不相符的，就该交换了。代码如下：

10.【922】按奇偶排序数组II

​	分析：用上面的优化思路即可，整体思路是交换，一个指针遍历偶数下标，一个指针遍历奇数下标。两个指针独立，需要二者都小于最大下标。注意下标各自+=2.

11.【3467】将数组按照奇偶性转化

​	分析：本题和【905】类似，需要把奇数往右侧放置，偶数放到左侧，只是遍历的同时需要修改值。不同的是，while的条件是i <= j，因为最后一个也要判断和修改为1或0。

12.【2460】对数组执行操作

​	分析：就是简单的模拟，遍历一边可以完成所有操作。然后需要把所有的0放到最后。其实就是删除0的操作。总共遍历两次是可以实现的。

​	想想能不能一次性就优化呢，如果发现nums[i+1] == nums[i],我需要把nums[i]乘以2，nums[i+1]改为0。你现在其实就知道了它是0，下次遍历到0的时候，你就可以让slow的位置承接结果了。因为slow总是很慢的。fast指针在前面修改就好了。最后需要把slow右侧的位置置0即可。

13.【1089】复写零

​	分析：最简单的思路是暴力，遇到0就开循环把后面的处理一遍，不过O(n^2^)也勉强可以过。

​	可以优化到O(n)，你可以想象一下，如果不删除，这相当于把所有的0后面再次插入一个0，即原本的一个0象征着两个0，然后最后截取k（原来nums的长度）就是后来的nums。

​	如果我们统计一下一共有几个0，那这就意味着我们就确定好了复制0之后的序列，从右侧往左侧看第几个数是结果数组的最后一个数。这之间的数都会因为超过k而不需要。举例[1,0,2,3,0,4,5,0]，k = 3，从后面往前看，最后一个0代表两个数，5代表一个数，所以4应该是结果数组的最后一个数。**逆序用快慢指针从后往前遍历就好了。**

​	整体需要扫描两次数组，时间复杂度是O(n)，空间复杂度是O(1).

14.【75】颜色分类

​	分析：当前题目我已经写过了，但是写一下进阶的思路 - 三速度快慢指针之两个慢指针。

​	本题的意思是给一个只有0,1,2的数组排序，进阶需要我们只遍历一次。我们采用刷漆的思路。由于最后0集中在最左侧，2集中在最右侧，1集中在中间。所以优先级是2>1>0，即2最快，1中间，0最慢。

​	快指针负责把它经过的地方涂成2的颜色，这样可以确保最右侧区域一定是2。中速指针负责把它经过的地方涂成1，慢速指针负责把它经过的地方涂成0的颜色。由于它最慢，所以确保了最左侧是集中的0.

​	关键是如何让中速和慢速移动。我们的思路是优先级最高的先涂，这样最后涂色的会覆盖掉之前涂的颜色。如果遍历到0，就会让1的指针++，0的指针也会++，这相当于1的数量没有变，0的数量+1；如果遍历到1，会让1的指针++；0则不变。这样就保证了三种颜色分居于正确的位置。

===================8.17======================

-- 今天刷双序列双指针，目标二十道题，熬夜刷。

1.每日一题：【837】新21点 - 逆序dp有点难

​	分析：看了题解知道了，本题的意思是求Alice的胜率，即Alice从[1,maxPts]的分数里任取一张牌获得分数，从0开始计分，每次都可以从这个范围内抽取且等概率。当Alice的分数>=k的时候则不能继续抽，求最后Alice的分数不超过n的概率。

​	本题很容易想到Dp，但是如何想Dp的含义很难。题解中说Dp设置为当Alice的分数为i时，它获胜的概率。答案求的是dp[0]。即`求谁设谁`。Alice获得的最大牌面是k-1+maxPts，我们记maxPts为w，即需要一个dp[k+w]的数组管理。很显然dp[k]到dp[n]都为1，dp[n+1,k-1+w]都为0. 而前面dp[i]其实就是后面w个概率求平均罢了。因为后面每一个都是等值的。所以这个构造dp的过程可以用**滑动窗口**，避免重复求和。

2.【2109】向字符串添加空格

​	分析：本题的题意很好理解，给我一个索引的列表和一个字符串s，需要修改s，使得结果字符串的索引列表中的索引处是空格，其它按原顺序排列开，这相当于插入几个空格到指定索引位置。

​	暴力是O(mn),即每次调用一次insert方法。看看能否双指针优化一下。我们的目标是扫描一趟s就好了。有思路了：这种插入确定数量的都可以先把位置resize好，然后我们的目标就是把s摊开，所以需要快慢指针逆序处理，slow负责在最后往左侧接收，fast负责往前遍历。这么看本质上还是单序列的双指针，另一个列表只是辅助信息。试试吧。

​	本题其实用到了三个指针，一个指针slow负责接收置位新元素，一个i快指针负责遍历原来s的部分，一个j负责管理space的索引。

​	本题的时间复杂度是O(m+n).

反思：**三个指针在访问之前都一定要确保不越界**。

3.【2540】最小公共值

​	分析：太简单了，已经是有序的了，就是两个指针一人一个，谁小谁就++，遇到相等就return了。比第二题简单很多。

4.【2570】合并两个二维数组- 求和法

​	分析：也很简单，双指针一起走，比id就行了，如果一样大，就合并push到结果中然后一起++，否则谁的id小就把它push到ret中，单独++。

5.【350】两个数组的交集II

​	分析：本题是不需要去重的，原两个数组中有多少次，就需要返回多少次。比如5在nums1中出现了两次，在nums2中出现了三次，那ret中应该有2次。结果的顺序不重要。

​	我能想到的思路是：各自排序，然后双指针，复杂度取决于排序，即是O(nlogn + mlogn)的。这个数据量是可以ac的。其实也可以考虑hash。值的范围是0到1000，考虑计数排序，这样复杂度就会更小。可以做到O(m+n).空间复杂度也是O(m+n).

6.【LCP 18】早餐组合 - 看题解

​	分析：我深深收到了两数之和的影响，我试图排序之后找到一个邻接，然后用乘法，实际上这是没有办法实现的。就像 5+5=10,2+8也等于10，指针不好动的。

​	看了题解我懂了，排序是一定要排序的，但是排序的目的是为了有序，**双指针优化的目的是让一步判断就知道一行的信息**。而相向双指针就可以知道这样的信息。我们让i从0遍历主食，j从饮料的最后开始遍历。如果之和小于等于x，说明小于=j的都可以买，这个时候说明j不需要动，价格还不高。只需要让i++即可。否则说明饮料价格高，需要j--，一直到满足之和小于等于x，就可以为该主食寻找饮料数了。

​	整体的思想是：为每一种主食都寻找到最大复合条件的饮料数，**<u>而随着主食变贵，与之搭配的最贵的饮料的价格应该下降</u>**。这就是双指针方向选择的原理。如果都同方向变化，那显然是无法一下子知道一行的信息的。

​	总结：双指针范围的问题，**指针移动的选择问题应该想一下双指针的本质是什么**？**随着一个的变化，另一个应该如何变化才能一步知道更多信息。**

7.【1855】下标对中的最大距离

​	分析：本题的思路也想了很久。i确实要遍历每一个元素，为每一个元素确定第一个小于自己的数。这样这个数的左侧且自己的右侧 （包括自己）就都是符合要求的了，这也符合**双指针优化时间复杂度是本指 - O(1)的操作知道O(n)的信息**。

反思：有一个小细节要注意，while退出的时候，j指向的都是 < nums1[i]的数，所以ans的max **比较对象是j-i-1**。

8.【1385】两个数组的距离值

​	分析：需要对两个数组排序，然后两个指针往后走，arr1[i]知道之后区间就知道，由于我们需要同时确保arr2的每一个数要么在区间的左侧，要么在区间的右侧，而且需要常数时间知道。我需要while循环判断左侧，只要arr2[j] < left我就继续让j++，一直到不满足，我就if判断右侧是不是满足arr2[j] > right，如果不满足，该数作废。否则右侧的所有数都满足。整体思路我想出来的就是这样子。这样也可以确保全程只遍历一次arr2.整体的复杂度取决于排序。好在数据量不大。

​	反思：有可能在while尝试是否小于left的时候**，j一直++导致到了arr2的最后越界了，这个时候这个元素一定是符合要求的，这意味着整个arr2都小于left**。j移动到最后的最后，arr1的后面的都符合要求了（因为区间左端点右移了，意味着更大了，arr2的元素更小于left了，而右侧都没有元素了）。

==============8.18============

1.【925】长按键入

​	分析：给你两个字符串s和t，如果s的某些字符在其原来的后面重复若干次得到t，则返回true，否则返回false；如name = "alex", typed = "aaleex"返回true。很显然遇到相等我们就齐头并进，否则检查typed这一边是否是因为重复造成的。确保下标合法即可。

2【679】24点游戏 - 回溯

​	分析：每日一题，今天是hard题。数据量不大，直接回溯暴力搜索。**注意double不能直接用 ==** ，而是作差比一个小数更小，如10^-6^。还有就是排列的时候是全排列，A~4~^3^种。

3.【809】情感丰富的文字 - 双序列的分组滑动窗口

​	分析：数据量不大，肯定要遍历每一个word了，判断word是否可扩张为s。通过两种操作，一种是将word中的某一个字母扩展三次以及以上，或者将一个双字母扩展为五个。双字母扩展为五个我可以理解为选择一个扩展为四个，本质上还是第一种的扩展。所以我们可以两组并行分组循环，首先比较种类是否一样。然后重点是检查什么情况不可以扩展1 -> 2的情况是不行的。

​	总结：如果word中对应的字母数量等于s中的，那没事；如果大于，不行；如果小于而且s中的小于3，那也不行。

​	这是双序列的分组滑动窗口。有点意思。

4.【392】判断子序列

​	分析：本题做过，dp可以用来解决子序列的问题，但是本题双指针会更快。

5.【524】通过删除字母匹配到字典里的最长单词

​	分析：本题是模版题，给你一个字符串s，给一个字符串列表strs，你需要在strs中找到s的最长且字典序最小的子序列。思路：遍历strs中的每一个字符串，判断是否为子串，如果是，判断长度是否更长且字典序是否更小。

6.【2486】追加字符以获得子序列

​	分析：本题的本质还是双指针判断是否子序列，最后子序列的指针停止的位置以及以后的长度就是结果。

7.【2825】循环增长使字符串子序列等于另一个字符串

​	分析：给我两个字符串，s1和s2；我理解错题意了，**可以无限次操作（对于一个字符只能操作一次）**，选中s1中的字符，**<u>循环增长+1</u>**，如z变a，a变b，使得满足操作后的s2成为s1的子序列。思路：本质还是判断子序列那一套，判断是否相等，如果不相等就在操作次数足够的前提下尝试消费一次操作次数，即判断s1[i] + 1是不是等于s2[j]。

​	最后返回j的指针的位置和s2的大小关系。

8.【1023】驼峰式匹配

​	分析：比较简单，对于一个字符串，一次遍历就好，双指针如果相等，都++；否则判断不相等的s1[i]是不是小写字母，如果是，还有的看，否则出现了大写字母，直接没戏了。

9.【3132】找出与数组相加的整数II

​	分析：数据量不大，可以排序，给定两个有序的数组，我需要从nums1中删除两个元素之后，满足nums1剩余的元素全部 + x之后和nums2分别相等。

​	这类似于分别等差的子序列了。要求返回最小的x。即可能删除两个数有多种可行解。由于删除两个元素，所以最多三种情况，我就枚举这三种情况就好了，nums2[0]可以和nums1[0]\nums1[1]\nums1[2]分别match，不可能和更后面的数match了。match之后就相当于假定了两个子序列的差值**x = nums2[0] - nums1[j]**,j = 0,1,2; 首先要确保子序列存在，然后才是找符合条件的最小x。

10.【522】最长特殊子序列II - 看题解

​	分析：本题有点难，看了题解之后会了。由于一个字符串越长，就越不太可能成为别人的子序列。所以可以先对strs按照长度降序排序，然后贪心的让一个字符串本身判断是否是剩下的每一个字符串的子序列。所以需要两重for循环，任取两个（有序）来判断。由于我们是降序排序过的，所以只要发现自己不是任何一个除了自己的子序列，就可以返回了。可以用一个flag标志是不是存在一个非自己的字符串，自己是它的子序列。

===============================8.19===========================

1.【2348】全0子数组的数目  - 【分组循环滑窗】

​	分析：子数组问题，优先考虑滑动窗口，求全0的子数组的数目问题，我们需要遍历一遍数组，只要发现不是连续子数组就开始收集，当且仅当左侧一段是连续0才收集，其它情况只需要更新窗口的left指针的位置即可。长度为n的连续0的子数组个数可以用梯形面积的公式计算。注：最后一段可能是全0所以需要哨兵辅助。

2.【2367】等差三元组的数目  - 看题解 - 三指针优化

​	分析：给你一个升序的数组，找到等差三元组的数目，我的想法是先hash计数一下，然后一个指针从第一个cnt不为0的地方开始，然后后面就一直按照等差的顺序去寻找，只要j的cnt不为0就继续往前跳跃并把经过的地方修改为cnt  = 0，一直到cnt为0的地方，就开始收集。 复杂度是O(n^2^)。我用了map，也ac了，但是复杂度不够。

​	用三指针优化：思路，快指针往前面遍历走，两个慢指针i和j，确保j永远比i大；思路是while让j先到达比x小diff的数，如果循环停止的时候nums[j] + diff > x，则continue；否则让i跟上。就是这样的思路。前面枚举三元组的落点，而不是枚举起点。很有意思。	

​	所以很多时候你的双指针不是很有效的时候，不妨想一下，是不是自己的双指针的枚举思路和顺序出了问题。**枚举起点就会出问题。**

3.【3652】按策略买股票的最佳时机

4.【2461】长度为K的子数组中的最大和

5.【3634】使数组平衡的最少移除数目

​	分析：因为删除之后是子数组，而且涉及到最大值最小值，顺序对结果没有影响，所以可以先排序，用滑动窗口，窗口的右侧就是max，窗口的左侧就是min。。

注意

* 本题要注意第一个点是如果只有一个元素，必须特殊判断，提前return，因为它是平衡的。
* 第二个注意的d地方是k * nums[i]之后可能会越界int，所以用long long强转。

6.【3643】垂直翻转子矩阵

​	分析：类似于翻转字符串，数据量不大，时间复杂度是O(k^2^).

===========今天是最后一天了，滑窗和双指针结束了，进阶后面再说吧，我需要总结一下==========







