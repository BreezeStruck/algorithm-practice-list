[[分享丨【算法题单】滑动窗口与双指针（定长/不定长/单序列/双序列/三指针/分组循环）- 讨论 - 力扣（LeetCode）](https://leetcode.cn/discuss/post/3578981/ti-dan-hua-dong-chuang-kou-ding-chang-bu-rzz7/)](https://leetcode.cn/discuss/post/3670978/ling-shen-ti-dan-yu-gong-si-bi-shi-ti-de-eh4x/)

-- 这周是**大厂面试高频考点**，来自上面大佬整理的题单。都是历史真题。八月份剩下的三周就写这个。

-- 本周写灵神的滑窗题单

# 定长滑动窗口

=================8.6==============

1.【1052】爱生气的书店老板

​	分析：minus的大小的窗口一直滑动，窗口内的顾客肯定满意，满意的顾客还要包含窗口之外不生气的；所以包含两部分。我们可以遍历整个数组，然后每一个地方都求一个满意的人数，最后迭代一个最大值。这是暴力的方式。

​	显然暴力超时了。我们可以这样想，整个过程，老板不生气的时候的顾客一定是满意的，不管这个不生气是不是在我的窗口内，都是不生气的，都是可以独立计算的，而生气的就是反动派，我们要让反动派最多出现在窗口内，即让老板生气的时候，而且顾客最多的时候老板抑制自己的脾气就好了。

​	所以问题转化为两部分，一部分正常求顾客人数-本来就不生气的时候。一部分是窗口内的生气的时候，要让生气的时候的人数达到最大值，显然这也是我们需要团结的力量。

​	遍历窗口肯定是O(n)，我们争取一次遍历解决问题。我们可以用一个两个元素的数组，0索引代表整个过程的本来就就不生气的顾客人数的计数器。1索引代表窗口内生气时的顾客人数的计数器。我们从0开始到n-1都需要收集；我们滑动窗口要做的是站在窗口右侧的角度处理，即如果i太小，我们就continue；如果到了窗口的右侧边沿，我们就尝试更新全局的max_val-窗口内生气的人数，然后才是滑动的过程，一旦滑动，我们就需要更新s[1]-即窗口内生气人数，前提是刚刚离开窗口的是生气的我才需要减去它。

​	最后返回s[0] + 全局窗口内生气人数最大值。

​	初次接触还是挺难的。这个问题的难点在于：①生气和不生气独立分开计算；②滑动窗口解决生气人数的最大值，最后两部分加起来。我们窗口内只需要维护生气的人数就好了。其实还是需要全局变量来记录整个滑动过程中的生气人数最大值的。

​	自己写一下代码。

问：如何理解窗口滑动的时候的那句代码？

答：由于第一个窗口的右边沿就已经累加出来此时生气的状态了，所以就可以更新全局最大变量了；所谓窗口滑动，是来到每一个合法的地方就立刻加上这个状态，这可以理解为窗口右移时处理右边沿新加进来的状态。而-=的代码是让左边cut掉，是为下一次的窗口滑动作准备。

​	至于顺序为什么要这样安排？右侧 -> 更新 -> 左侧这样的滑动过程。你可以理解为，我来到一个新的窗口右边界，我需要加上这个新值，我就可以立刻更新了，因为我的左边界在上一轮循环已经帮我处理（-=）好了。

​	其实按照常规思路，应该把右边界和左边界的处理挨着处理，然后再更新全局最大值变量，这样符合常理。但是这样的坏处是边界的窗口需要单独拎出来讨论，否则会造成数组越界。就像第一个窗口没有上一个窗口，那就需要单独处理。显得很麻烦。倒不如颠倒一下顺序。每一次到达新的窗口右边界，就加上右边，此时就已经是新的、长度为minute的窗口了。这样就可以更新。然后在本轮循环的最后进行左边界的cut，为下一轮循环做准备。

```C++
class Solution {
public:
    int maxSatisfied(vector<int>& customers, vector<int>& grumpy, int minutes) {
        int max_grumpy = 0, s[2]{};
        for(int i = 0;i < customers.size();i++) {
			s[grumpy[i]] += customers[i];
			if(i < minutes-1) continue;
			max_grumpy = max_grumpy > s[1] ? max_grumpy : s[1];
			s[1] -= grumpy[i-minutes+1] ? customers[i-minutes + 1] : 0;
		}
		return max_grumpy + s[0];
    }
};
```

2.【438】找到字符串中所有字母异位词

​	分析：给我一个s串，一个p串，要求找到s中所有的p的字母异位词。返回他们的起始索引的数组。

​	如果暴力，时间复杂度是O(n^2^k).但是由于是字母异位词，所以子串的长度知道，即我只需要遍历一遍，就可以对寻找子串的过程进行剪枝，所以暴力的复杂度可以优化到O(nk)，还是太慢了。既然子串的长度固定，就让我想起了固定的窗口的滑动。遍历的过程，携带一个长度为len(p)的窗口。尝试用滑动窗口解决。

​	我们可以先试试笨方法，每次窗口当判断都用一个26的hash，也相当于是O（1）判断吧。其它的操作类似于滑动窗口的模版了。写一下代码。

​	心得：其实还是按照灵神的专题刷题比较好，这样效率很高，巩固也很强。一个题kei明白之后，所有的基本都是一个套路。一天刷十道题没问题。【1052】已经是比较难的滑窗了，如果这个题学会，其它应该问题不大。就让1052是一个模版题目吧。多看题解还是有好处。这个题我就是独立写出来的。按照灵神的题单和题解刷算法，真是享受。十点半去洗澡。

3.【1456】定长子串中元音的最大数目

​	长度固定的子串，很显然是滑窗的模版题目了。本题给我一个窗口大小k，要求找到给我的s的大小为k的子串中的最大元音字母数。模板题了。

​	自己ac了，但是我看到灵神的这个题解关于离开窗口的注释是最清楚的 -- “为下一轮循环做准备”，附上灵神的代码。

```c++
class Solution {
public:
    int maxVowels(string s, int k) {
        int ans = 0, vowel = 0;
        for (int i = 0; i < s.length(); i++) {
            // 1. 进入窗口
            if (s[i] == 'a' || s[i] == 'e' || s[i] == 'i' || s[i] == 'o' || s[i] == 'u') {
                vowel++;
            }
            if (i < k - 1) { // 窗口大小不足 k
                continue;
            }
            // 2. 更新答案
            ans = max(ans, vowel);
            // 3. 离开窗口，为下一个循环做准备
            char out = s[i - k + 1];
            if (out == 'a' || out == 'e' || out == 'i' || out == 'o' || out == 'u') {
                vowel--;
            }
        }
        return ans;
    }
};
```

4.【643】子数组最大平均数 I

​	分析：长度固定是k的连续子数组-定长的滑窗，求什么花样都是一样的，求的是窗口的平均值，本质上就是求最大和。模版题。别看通过率只有44%，但是如果你掌握了滑窗的模版思想，你就会一分钟一气呵成秒掉这个题目。就这么简单。这就是刷题的正确方法-“**不会永远痛苦**”。

5.【1343】大小为K且平均值大于等于阈值的子数组的数目

​	分析：给我k，给我阈值。让我返回整个arr的大小为k且均值大于阈值的子数组的数目。大小为k的固定子数组一定是定长滑窗解决。维护一个窗口中的sum，然后每次处理的时候，就尝试让均值和阈值比较，尝试更新cnt；模版题。果然灵神的题解和我一样了哈哈。开心~

6.【2090】半径为k的子数组的平均值

​	分析：花里胡哨的，本质上窗口大小就是2k+1，然后滑动窗口，处理的逻辑就是求截断平均值放入arr就行了。模版题。

​	注意事项：会超过int的范围，改成uint_64维护sum就行。第二个注意事项是初始化为-1，会节省很多精力。

7.【2379】得到K个黑块的最少涂色次数

​	模版题。用一个计数器统计窗口内的W的数量，然后每次处理都更新全局的min_w，最后返回就行。

8.【2841】几乎唯一子数组的最大和

​	首先要理解几乎唯一子数组的内涵是内部至少有m个互不相同的元素的子数组。关键是我们在处理的时候如何判定当前窗口是几乎唯一子数组。我们可以维护一个长度为k的hash，每次都遍历一遍这个hash，看看不为0的元素是不是满足个数>=m；如果是，我们才尝试更新最大和。复杂度是O(n * k);想一下是不是可以优化判定呢？

​	我们可以反着想，几乎唯一子数组也可以理解为相同元素的个数不超过k-m，这样我们一边遍历，一边维护一个visited；如果出现过，我们就让cnt++；这样就避免了每次都遍历hash。

​	这个题有点复杂的，我们做题的时候脑子要保持清醒，尤其是下标的含义时刻要铭记。离开窗口的时候和加入窗口的时候处理的变量有点多。写个题解吧。

9.【1423】可获得的最大点数

​	这个题也是滑窗，但是不是一眼看出来的，因为只能从最开始和最后面摸牌，但是整体上来看，你摸牌的这些牌都是连续子数组的一部分。但是不同的是，这个子数组比较特殊，首尾的地方是连续的，而且你必须从第一个开门或最后一个开门，即子数组必须包含这两个元素中的其一。从这个意义上来看，我们可以想想一下，把首尾拼起来构成一个“环”，而且滑动窗口滑动的范围是有限的。

​	所以我们可以重新构造一个nums，把问题转化为我们熟悉的问题，如下图所示：

<img src="第五周.assets/1754473201643.png" width="400px">

​	所以我们只需要把两侧一共2k个元素按照5 6 1 1 2 3 这样的顺序，构建一个新的数组即可。当然我们不排除原本的数组就很小的情况（nums.size() < 2k），那怎么构建呢？

<img src="第五周.assets/1754473538193.png" width="300px">

​	看这个例子就知道了，哪怕首尾的重叠也不要紧，把头k和尾k调换顺序拼起来正常遍历就好了。只要不是一共k个的情况都需要如上处理。

​	100%ac了，关键是要知道先放尾k个，再放头k个。

10.【1652】拆炸弹

​	这个题也用到了循环数组，上面我们处理循环数组的方法是转化问题，转化为正向的处理方法。本题不同的k，正、负、0处理的手段是不一样的，0好说。

​	先看k是正数的情况，将每一个数替换为后k个数的和。负数则反之，将每一个数替换为前k个之和。既然有连续子数组的和，我们就滑动窗口就行。滑动窗口处理的过程，就是把sum赋值给窗口之外前面一个的过程。唯一注意的地方是，要确保修改之后不会影响后面的值的计算。**我们要意识到，循环数组中，所有窗口的个数恰好是原数组的个数**，而不像非循环数组那样-窗口太小就continue。

​	为了方便处理，我们应该扩充数组，即在后面建立虚拟的节点辅助我们更新，否则一旦值被修改和覆盖，就无法完成某些边界值的更新了。

​	我们的扩充手法是：把头k个元素复制一份插入nums后面。后面就变成正常的遍历操作了。注意第一个窗口就不遍历了，因为最后才会遍历。

​	如果k是负数。把尾k个头插入数组nums，然后最后一个窗口我们不要。**注意要用到窗口的大小是-k**。

​	这个题也不难，主要是1423的变式题。

11.【3439】重新安排会议得到最多空余时间I

​	这个题题意需要理解半天，就是给我一个最大的活动时间，这个数轴上有若干个会议区间互不重叠。我可以调整k个会议的位置，在保证会议时长和相对顺序不变的前提下，求的是调整之后相邻两个会议之间的空闲时间的最大值。

​	我们可以把问题转化为合并空余时间的问题，如果k = 1，可以调整一个会议的位置，为了腾出更多的连续空余时间，我应该让这个会议挨着别的会议，这相当于合并了两段空余的时间，类似的，k=2时，我更倾向于让调整的目的是凑一个更大的连续空余时间段，即都是为了那个最大的结果贡献力量。以此类推，合并k+1个空白的时间段，使得和最大就是我的目的。由此，可以转化问题，原本的区间的空白可以用int表示，这样就转化为了数组，两侧也需要表示，但是两侧可能是0-没关系，所以把问题转化为一个长度为n+1的数组，求窗口为k+1大小的子数组的最大值的问题。

​	这显然是滑窗的问题，这题**难在转化问题**。不在coding。

12.【2134】最少交换次数来组合所有的1II

​	这个题我是不知道怎么想到用滑动窗口的。关键是要想明白如何转化问题才是关键。

​	题意是给我一个环形的二进制数组，要把所有的1聚合到一起，通过交换1和0的位置，实现1的聚合。问最少交换次数。最后的效果是要把所有的1聚合到一起，所以看了题解我懂了。

​	数1的个数cnt，然后以cnt为窗口大小滑动这个环形数组-环形的问题已经说过很多次了，就扩展数组就好了。最理想的情况下是已经给我聚合好了，这样就不需要滑动了，为什么？因为里面都是1，没有0!正常情况下，窗口滑动时应该有0的，所以我需要维护0的个数，窗口内0的个数的最小值就是需要和外界的1的最少交换次数。

​	转化问题很关键！在处理问题的细节上，我们需要把头k-1个复制一份扩展到最后。

​	细节：如果k=0，直接返回0即可。

13.【1297】子串的最大出现次数

​	因为我不知道窗口多大，给了一个窗口的范围，所以只能遍历每一个k，在每一个k下使用定长的滑动窗口，这个题的时间复杂度是O（n * m）。倒是不难看出来，这个题和我之前写的一个题的思路是很类似的，这个题要求子串的不同的字母出现的次数小于等于maxLetters，之前有一个题是要求逆向转化-**几乎唯一子数组的最大和**。

​	不同字母数小于等于maxLetters，我们也可以用hash直接统计窗口内的不同字母的数量。离开窗口的时候别忘了更新就行。直接coding吧。

​	**<u>教训：拷贝字符串的时候，注意不是闭区间拷贝，右边界是开区间。</u>**

​	而且我这个超时了，遍历每个k是不行的，最后两个样例没办法过。

优化：

​	这个题的窗口大小就是minSize，**<u>因为长的串如果重复，那么它的子串一定也是重复的，所以如果结果出现在多次大串，那么其实这个大的窗口是一定包含小串的，小串也一定重复，而且小串的不同字母个数一定满足条件，而且小窗口的字符串还可能出现的更多。所以肯定不会选择大窗口，所以maxSize没有用</u>**，这个题只需要考虑窗口大小是minSize就好了。

【11.12.13都有点绕】

14.【2653】滑动子数组的美丽值

​	我理解错题意了，题目中说的第x小说的是大小，不是第几个的索引。所以需要滑动窗口。

​	关键是寻找窗口内的第几小的数，我们注意到nums[i]的范围只有-50到50，所以考虑计数排序，维护一个hash，每次处理的时候都从0开始到100遍历，看看不为0的下标是多少，找到第x个不为0的元素，如果下标是小于50的数，那就是负数，就把这个下标-50push到ret中，否则push 0；相当于滑窗+计数排序吧，否则很难找到更好的寻找第x个小的数的方法了。

​	**<u>需要注意的是用桶排序寻找第x小的元素的时候的方法，count不是++，而是要加上cnt[j]，比如它是5，说明窗口内有这么多j-50这个数。</u>**

=================8.7===============

=> 2000分以上的就不写了，太难了。

# 不定长滑动窗口

1.【3】无重复字符的最长子串

​	分析：子数组和子串的问题，而且不是定长的，那就用不定长的滑窗尝试解决。循环遍历一次，i代表窗口的右侧指针，还需要一个左侧的指针代表窗口的左边界。

​	我们要维护一个窗口的内的不重复的字符的种类数cnt，然后维护一个全局的最大值ret，记录符合要求的子串的长度最大值。由于要处理不重复，必须用到hash统计次数。

​	我们的处理逻辑是：循环开始尝试计数之前，判断是否出现过，如果出现过更新左指针，让左指针右移，并更新hash，一直到这个字母没有出现过。此时再更新hash。那么此时就可以更新新的ret了。如果一开始就没有出现过，那就cnt++，然后更新ret即可。

​	最后返回ret。

​	自己写出来了，但是我觉得还可以统一一下我的思路。我们可以像定长的滑窗那样**<u>，先一上来就让窗口右移，即本题中先统计好新来的数量，然后我们循环处理左边界，一直到满足条件-窗口内符合要求为止</u>**。然后最后更新状态。这是不定长的三部曲。其实和定长的滑窗类似，定长的滑窗就是最后还需要搞一下左侧元素离开，为下一次做准备。

```c++
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
    	int l = 0, ret = 0;
    	map<char,int> mp;
        for(int i = 0;i < s.size();i++) {
        	char c = s[i];
        	mp[c] ++;
			while(mp[c] > 1) {
				mp[s[l++]] --;
			}
			ret = max(ret, i-l+1);	
		}
		return ret;
    }
};
```

​	这样代码可以写的规范、很短。

2.【3090】每个字符最多出现两次的最长子串

​	分析：字面意思，求的是满足条件的最长子串的长度，子串需要满足每个字符出现次数不超过2；子串问题优先考虑滑窗，不定长的滑窗求最大最小长度。

​	核心是判断是否存在字符次数超过两次，维护一个hash统计次数。每次先让右边界进来，然后用这个约束条件，更新左边界，一直到满足mp[s[i]] == 2为止。然后这个题就和【3】一样了。

3.【1493】删掉一个元素后全为1的最长子数组

​	分析：我们肯定删0而不是删1，那么我只需要维护一个窗口，让里面的0最多1个，如果发现两个了，那我就移动左指针，使得0的个数保持1个。

​	注意，是必须删除1个，哪怕里面没有0，也得删除一个1，所以我只需要最后返回ret-1即可，ret是满足条件的最长子数组的最大长度。

4.【1208】尽可能使字符串相等

​	分析：经过分析，发现s的子串，所以用不定长的滑窗解决，给了我最大的maxCost，我需要在这个限制的条件下，维护一个cost变量，含义是窗口内的转化开销。每次都尝试转化，增加成本，while 成本超过maxCost，我就更新左边界。然后更新ret即可，比较简单。

5.【904】水果成篮

​	分析：开始看不懂，后来看懂了，是题目描述不清楚。给我一个数组表示水果树，数组的值表示水果的种类的序号，我现在要从某一棵树开始摘，摘完一个水果就到下一棵树摘，所以是连续子数组问题，用不定长的滑窗解决。最多两个篮子-每个篮子只能装一种水果，意味着我只能让窗口内最多出现两种元素。这也是左指针移动的限制条件。

​	返回的是最大的子数组的长度。那就简单了。

​	反思：ac了，但是我用了variety来维护hash中频数不为0的元素的种类数。其实可以用**unordered_map的erase方法把频数为0的直接擦出掉**，然后while循环的条件用size()和2比较即可。

`map也有erase方法，传入key即可。`

6.【1695】删除子数组的最大得分

​	分析：经过分析，问题转化为求一个包含不同元素的子数组，使sum最大，返回这个sum，整个数组都是正整数数组。我只需要中间ret迭代记录中间的sum即可。窗口只需要保障满足不同元素即可，即刚刚进来的这个元素的频率 == 1。因为我窗口内之前都是维持的不同元素，出现具有相同元素的情况只有刚进来的这个数可能造成这种局面。

7.【2958】最多K个元素的最长子数组

​	这个题和上题没区别，给了一个k，要求子数组内（窗口）内的所有元素的频率小于等于k，改一下while条件就好了。返回最大长度。

8.【2024】考试的最大困扰度

​	分析：问题转化为给我一个包含T和F两种字符的字符串，给我一个最大操作次数K，每次操作我可以实现某个位置上的FT求补操作。问互换后最大连续的F或T的长度。

​	这个题目当然是允许最多存在K个F（假设主T，即替换F为T），维护这样的一个窗口，最后返回最大长度。难点在于你不知道主F还是主T，大概想一下，应该是谁多我就主谁。如果T更多，我更希望修改少的，这样出现最大的概率要大一点，但是不知道是否绝对。

​	最笨的方法就是写两种情况的代码，但是效率肯定很低。我们要证明一下这点，假设T更多，比如T=6，F=4，k=1，如果这四个F是连续的，那确实可能连续的F更长。所以不能简单的根据谁多谁少就判断。

​	我写两遍吧，ac了，但是太臃肿了。我应该想想如何把这两种情况合并。我看评论区很多人也写了两遍hh。

​	我让AI帮我合并了一下，AI的意思是写在一起的时候，如果两个都超过了k，那肯定不行，所以只需要让一个不超过k，一个超过k就行，或者两个都不超过。即while的条件写a>k and b>k这种，即min(cnt['T'],cnt['F'])>k，这样就可以合并了。因为我们的初衷就是不让TF两个都同时大于k。

​	所以我把代码优化地很简洁了，其实就是两个都大于k的时候左指针才需要移动。

```cpp
class Solution {
public:
    int maxConsecutiveAnswers(string answerKey, int k) {
    	int ret = 0,left = 0;
    	map<char,int> mp;
    	for(int i = 0;i < answerKey.size();i++) {
			mp[answerKey[i]] ++;
			while(mp['F'] > k and mp['T'] > k) {
				mp[answerKey[left++]] --;
			}
			ret = max(ret, i-left+1);
		}
		return ret;	
    }
};
```

9.【1004】最大连续1的个数III

​	本题比上一题还要简单，其实就是上面一题我提到的臃肿的代码中第一种情况，二进制数组，现在指定了翻转0为1的最大次数k，让我返回翻转之后最长的连续1的子数组的长度。即窗口内容忍有k个0。

10.【1658】将x减到0的最小操作数 - **要有逆向思维**  - 思维上有点难度

​	这个题就类似于之前做的定长的滑窗的一个首尾挨着的卡牌的+题目。这个题的数组也只能是从头和尾巴开始摸牌，然后和是x的最短连续子数组，当然也可能都凑不正好x，我们处理这种特殊情况就是靠初始化为-1，如果ret没有被更新过（当且仅当满足sum == x才更新），我们依旧返回ret就可以覆盖。

​	环形的处理手段就是复制一份，而且必须包含首尾的两个。所以遍历顺序是有讲究的，这个又是不定长的。难点就在于如何滑动。其实应该是从中间往两侧滑动。需要满足窗口的大小 <= 本来的大小。

​	关键是往两侧滑动怎么实现。**<u>不会了，不知道如何滑动环形的了</u>**。看看题解。我懂了，逆向思维。拿掉两侧的，相当于剩下一个连续的子数组，我就可以滑动中间剩下的这个窗口了。相当于我在求最长的和为total-x的子数组的长度。真聪明奥。

​	写一下代码，我一直维护窗口内的sum保持 <= total-x即可。这样更新之前，我只需要判断是不是等于total-x即可。

​	这个题我没有先排除一种特殊情况，**<u>就是所有加起来都无法让x减少为0的情况，要提前排除掉。否则会出现数组越界的情况。要优先排除这种情况。</u>**

​	







