## 7.29

1.【234】回文链表 

​	分析：如果可以用辅助数组确实很简单**-copy+双指针就好了**。但是我想挑战一下空间复杂度O(1)；我想不出来，因为诶这个题目需要修改链表结构，即把链表的**后半部分反转一下，然后从后半部分开始一个指针，从最开始开始一个指针比较是否相同**，然后此方法存在并发控制的问题，因为涉及到了对链表进行写操作。所以还是有弊端的。这个思路挺好的了解一下，但是想要ac这个题目，还是copy+双指针吧。用递归的空间复杂度也是O（n）。

​	毕竟我们不是找工作面试，所以不需要管这些优化的问题。

2.【215】数组中的第 K 个最大元素【计数排序】

​	分析：减治法，这个题目我看了题解才知道；我本来想的是类似于堆排序的思路，复杂度是O（n * k）,不太稳定。要想实现O(n)，可以考虑减治法，但是实际操作下来类似于快速排序的快速选择方法还是在某种情况下退化到O(n^2^),所以还是会超时。

​	注意事项：索性就用空间换时间，用桶的思想排序吧还是。注意桶排序的时候，**<u>比如5的个数有100个，不要只push一次，而是要把100次就放如结果数组中。</u>**

3.【21】合并两个有序链表  分析：简单题目，类似于合并两个有序数组一样。

4.【5】最长回文子串【中心扩散法】

​	ac了，但是效率比较低。我是遍历s的每一个位置，然后利用回文的性质尝试往外扩散，然后奇数和偶数的情况都要试一试，因为你不知道回文串的长度是奇数还是偶数；所以要套两遍，复杂度是O(n^2^)的。已经尽力在避免重复判断回文了。我看题解里面dp的复杂度也不高，所以还是O(n^2^),而纯暴力是没有办法ac的。所以我的复杂度还算可以了。（我的中心扩散法应该是比较合理的方法了。能想到这个应该是对回文有比较好的理解了。）

​	优化奇偶：当发现连续的字符就把他们当做一个整体扩散。避免了重复计算。

5.【169】多数元素【摩尔投票法】

​	统计 + 找最大值秒了。时间复杂度和空间复杂度都是O（n）。但是这个题目还有一种我没学过的思路：

【摩尔投票法】

【【剑指Offer最优解】 39. 数组中出现次数超过一半的数字 ｜ 摩尔斯投票法】https://www.bilibili.com/video/BV1UB4y157UP?vd_source=db337c2a2fa9fcee88212163237d3921

​	学一下。懂了。这个摩尔投票法适用于一切寻找众数的方法。核心思路就是抵消。想象这样一个场景：要选举一个班长，A和B如果是最后决战的两个同学，他们一个人有50票，一个有49票，其实就和一个1票，一个0票没区别。反正第一个同学的投票数就摆在那，它是最有“钱”的，即抵抗消除能力最强的那个。

​	我们最开始是不知道谁是班长的，所以只能假设第一个人是，然后往后遍历，发现是投自己的，计数器就++；发现不是投自己的，就--，如果发现--完成之后是0，说明自己就被杀死了。同时，其它和我陪葬的人都死了。但是无所谓，如果我是最后的班长，后面仍然有我的身影，我依然有机会。从这个角度来看，是一个 “全局桶”的思想。一旦我被杀死。数组就缩小了。但是仍然不会影响最后的众数。

​	写一下代码，这个复杂度最低，时间是O(n)，空间是O（1）的，你只需要维护一个cnt，一个candidate；

6.【229】多数元素II  【摩尔投票法】

​	本次不是hot一百的题目，而是上面的题目的扩展。这个要求找出所有出现频率超过>n/3的数。

​	先说结论：摩尔投票发可以扩展到[n/k]的情形，而且很容易得到，次数超过[n/k] (向下取整)的数不超过k-1个。要澄清一件事：摩尔投票法不是用来求一个数组的最高频率元素的-即不是直接寻找众数的办法！！！因为前面的抵消会对本身是众数的结果产生影响。

​	**摩尔投票不是用来求众数的！！！**（即能用摩尔投票法做的求出来的一定是众数，但是求众数不一定可以用摩尔投票法来做，前提是你得保证众数超过多少百分比，如50%，33.3%等）所以你想求两次众数的想法就可以打消了。正确的做法是：

​	一层循环，同时维护两个最有希望的投票人。而不是顺序先找第一个，再找第二个。那样找不出来的-因为摩尔投票不是用来寻找众数的。同时维护两个。分多钟情况更新就好了。

​	最后还是需要判断一下选出来的这两个票数最多的人是不是满足条件才可以。

**注意事项：**

* 关于初始化：初始化0就行了，如果真的0，那也不影响；然后从下标0开始遍历就好了；
* **<u>关于判断顺序</u>**：**先判断是不是相同，然后判断是不是cnt为0（只能这样，不能换顺序，它不同于n/2的那种，这个怎么顺序都行）**；如果都不是，两个都需要--，相当于这个元素和它俩互相残杀。为什么是它俩同时cnt--呢？因为你就这么想，它俩都不和nums[i]相同，那就同时减少一票就好了。也只有这个时候才能抵消票数，为了公平必须同时减少票数。

7.【141】环形链表  【链表、哈希表】

​	分析：这个题是1，代码随想录上是2；这个简单一点，只是判断是不是有环，另一个是要找到入口；我仍然采用hash的做法。都可以秒掉。

8.【136】只出现一次的数字 【位运算】

​	这个题的题意是除了答案，别的数在数组中都出现了一次，要求在线性时间复杂度范围和常数空间复杂度范围解决。 哈希不满足，想不到。

​	看题解。用到了位运算，即异或运算，从bit的角度思考问题，如果两个数在数组中出现了两次，异或之后肯定是0，所以最后的答案肯定就是单数出现次数的那个。聪明！！！

​	但是我好像没用过异或运算。学习一下。	异或的算符是  `^`. 三行代码就解决了。本质上还是用到了异或的可交换这个性质。出现过两次的异或失效！！！

```C++
class Solution {
public:
    int singleNumber(vector<int>& nums) {
        int ret = 0;
        for(int n:nums) ret ^= n;
        return ret;
    }
};
```

9.【283】移动零【双指针】

​	这个题看起来很亲切，要求我使用原地操作，完成所有的0移动到数组的末尾。其实我一开始就想到了快慢双指针移动删除所有的指定元素那道题。只是那道题之后不需要在意后续的操作，这个只是把后面赋值为0罢了。

10.【338】比特位计数 【动态规划】

​	这道题暴力是O(nlogn)，即每一个都要重复count 1的个数。

​	可以使用动态规划，结合语境得到状态转移方程，甚至dp数组就是要返回的结果；其实这种需要为连续的、有关系的数字串构造一个东西的这种，都可以考虑dp，试图从语境中寻找关系。

​	一个数要么是偶数，要么是奇数；如果是奇数，则1的个数比小于它的最大偶数多1个，即末尾的1；如果是偶数，则其中含1的个数和它除以2的格式一样多，即和它右移一位的数含1的个数一样多，因为偶数末尾一定是0.就可以写了。

11.【543】二叉树直径 【二叉树、递归】

​	分析：这个题目就是暴力，写一个求最大深度的函数，然后深度搜索每一个节点，维护一个全局的max_path，对于每一个节点，都看看左右子树的最大深度之和是不是最大值，然后尝试更新最大值就好了。

​	优化：由于求深度和DFS都是在搜索这棵树，所以可以合并到一个递归函数里面去。这样其实才是最优解。

12.【461】汉明距离 - 【位运算】

​	有了上面的找出现一次的数字的那个题目的异或的经验，这个题目用异或就很简单。汉明距离是二进制不同的位置的数目。异或之后，只有不同的，结果才是1；然后数一下1的个数就好了 - 循环右移的思路，让cnt += 末位数（和1按位与运算）

唯一注意的是：**<u>右移或左移</u>**是一个算符，和加法一样，**<u>需要赋值生效的</u>**。

13.【448】找到所有数组中消失的数字 - 【哈希表】

​	这个题哈希统计肯定是可以ac的，但是不是最优解，即没有办法通过高阶的。最优要求空间复杂度是O（1）；但是经过我的思考，我发现很多题目你要想把空间复杂度降下去。就得修改原来的数据结构。而不能通过只读的方式实现O(1)的空间复杂度。

​	看下题解，这个题果然要实现O(1)的空间复杂度，就必须修改nums；这个题的灵感在于，nums的长度是n，然后要统计的也是n；那么我们就直接让nums作为一个哈希，关键点来了：对于数字nums[i]，其位置应该在i-1的位置上，如果这个数没出现过，我就让nums[i-1] 乘以-1变为一个负数，如果出现过了，注意，这个时候由于nums已经被修改过了。我们不要再负数的基础上在++，或者--了；我们需要先拿到复原之前的结果，继续处理下去！！！这样也不需要担心负数再次++恢复正数了。

​	最后统计一次，如果是正数，证明对应的位置没出现过。	开始很容易出错。

​	nums[i]可能是正数或负数，但是一定要取正数，确保访问index不越界；再就是判断这个n代表的哈希位置，即n-1为索引的num，是不是已经被访问过了。如果没有（>0）,那就需要设置为负数。

```C++
class Solution {
public:
    vector<int> findDisappearedNumbers(vector<int>& nums) {
        vector<int> ret;
        for(int i = 0;i < nums.size();i++) {
        	int n = nums[i] > 0?nums[i]:-nums[i];
			if(nums[n-1] > 0) {
				nums[n-1] *= -1;
			}
		}
		for(int i = 0;i < nums.size();i++) {
			if(nums[i] > 0) ret.push_back(i+1);
		}
		return ret;
    }
};
```

## 7.30

1.【2】两数相加 - 【链表】

​	遍历链表，把数构造出来，加起来，再头插法构造链表。时间复杂度是O(m+n)，空间复杂度都一样。是O(max(m,n));这种方法不行，long long也有几个方法过不了，故意卡的，暴力肯定不行了。

​	所以就必须逐位相加，考虑提示中的数字的范围是[1,100]，所以必须考虑进位。类似于加法器的思路吧。既然是逆序，开始的时候是小数，所以我们也采用这种思路。从小位开始加。如果当前两位和上一位的进位之和溢出（>10），我们只保存当前的个位数插入节点，然后把进位放入下一位处理。

​	看了题解之后，我感觉评论都忽略了数字的范围是[1,100]这个条件，好像默认范围是[0,9]，我们姑且这么认为。那么最大进位1和9和9也不会超过20，所以我们就采用朴素的方法。

​	从前往后遍历节点，保存结果，解析出来待插入节点的value -> sum % 10，进位则是sum/10，可能是1或0，下一轮的时候加上就好了。

​	但是链表最后可能有一个就是空了，因为链表不一定等长，那就让另一个为0就好了，也就是说要求求和的过程是分别进行的，累积的过程，而不是相加的过程。这样就保证了两个链表的独立性。

​	一会我们再来评价这个题的节点数值范围的问题。

评价和反思

* 最高位的进位要最后单独处理；
* 这个题的数值范围就是一坨狗屎，垃圾题目。给的节点范围是[1,100]，实际上测试全是[0,9]，一坨狗屎。

2.【22】括号生成 - 【回溯】

​	范围不大，需要中间结果，我第一印象却没有想到回溯，看来算法思维还没有形成，还得练。

​	每一个path的长度最后都是一样的，都是2n，所以这个树的深度一定是2n，每一层而言，只有两个结点。一个是左一个是右。很显然，维护两个变量，一个是左括号的数量，一个是右括号的数量，可以剪枝。因为满足左括号<n,右括号也是<n。

​	现在的难点在于怎么确保path顺着有效的括号方向发展呢。要么就放的时候放好，要么最后收集之前验证。显然验证的方法太费时间了。放之前就放好。如何约束呢？你要确保，path中的左括号的数量永远>=右括号的数量，**<u>即剩余的括号数量永远做到右侧括号的数量>=左侧括号的数量；</u>** 直接开始写代码。ac了。**太漂亮了这剪枝**。

```c++
class Solution {
public:
	int l_leave;
	int r_leave;
	vector<string> ret;
	string path;
	void backtracking(int n) {
		if(path.size() == 2*n) {
			ret.push_back(path);
		}
		
		// 左括号
		if(l_leave > 0 and r_leave >= l_leave) {
			path.push_back('(');
			l_leave --;
			backtracking(n);
			l_leave ++;
			path.pop_back();
		}

		// 右括号
		if(r_leave > 0 and r_leave >= l_leave) {
			path.push_back(')');
			r_leave --;
			backtracking(n);
			r_leave ++;
			path.pop_back();
		}
	}
    vector<string> generateParenthesis(int n) {
    	l_leave = n;
    	r_leave = n;
    	backtracking(n);
    	return ret;
    }
};
```

3.【48】旋转图像 - 【数组】

​	把一个正方形矩阵右旋90度，思考之后发现，可以对角互换，然后再左右翻转。

4.【49】字母异位词分组 - 【哈希表】

​	暴力先试试吧，由于每一个string的长度不大，所以比较字母异位词可以看做是 O(1)的操作，外层循环面向strs的各个字符串，然后和每一个分组的第一个比较是不是字母异位词。整体复杂度是O(n^2^);

​	能否优化到O(nlogn)或者O(n)呢？估计不太行。先写一下暴力吧。暴力超时了。

​	**但还是从暴力中吸取了一个教训**：在使用**<u>增强for循环</u>**进行**<u>写</u>**的时候，要用`auto & x：ret`，注意引用，否则只是修改了x的副本，而没有修改x，进而没有让ret造成影响。

​	方法就是运用了字母异位词分组的依据是字母异位词，**所以可以对字符串进行排序**，把相同排序的字符串放入同一个哈希表-value是一个Vec就好，最后收集哈希表的value构造ret。排序的开销忽略不计为O（1）,所以整体的时间复杂度是O（n）。

5.【64】最小路径和 - 【动态规划】

​	求最小路径和，题目背景和动态规划章节的不同的路径是一样的，很显然这个题目也可以dp，因为这种棋盘上dp很容易，要么就从上面来，要么是左侧来，求一个min，在加上自己就好了。

​	简单题，直接ac了。

6.【114】二叉树展开为链表 【二叉树的dfs】

​	这个题用辅助空间的话不难，关键是能不能原地修改二叉树呢？看看题解。

​	倒着想，结果是一棵右斜树，而且从上到下是先序遍历的顺序。我之前想过一个问题。那就是要修改一个结点的右侧指针，你最好确保右侧的子树已经访问过了。这样你修改自己的右指针才不会导致“孤岛”；从结果上来看，先访问右子树，就得到了一棵树的最“右侧”的节点，即结果最下面的节点。按照这个思路，我们可以对链表进行头插。

​	先序是根左右，我们可以逆序来，右 -> 左 -> 根，这样就可以进行头插构造这棵斜树了。我们无需new新的节点。可以使用一个虚拟头结点。写一下吧。

​	写起来还是很简单的，要有一个mindset，即右子树和左子树都递归处理好了，我如何处理呢？就是把我自己头插到list就好了。左右手都可以解放了，右手指向list的right，左手指向null...

​	压根不需要记住什么遍历的上一个结点，完全没必要。

7.【148】排序链表 【链表】

​	基本思路就是用辅助数组的思路，但是不满足进阶的要求，进阶的话必须迭代法实现归并排序了，这还是有点困难。就不写优化点了。基本思路还是容易ac的。

​	可优化：【迭代法实现归并排序】。  -- 你可以不想优化，但是一定要有这个意识。

8.【75】颜色分类

​	这个题就是排序，而且原数组只包含三个数，0和1和2，所以我打算用哈希进行计数排序，空间是O（1）的，也是原地排序。这个题是我见过最简单的题目了。但是遍历了两次，题目要求遍历一次。拉倒吧哈哈。

9.【208】实现Trie（前缀树） - 【前缀树\字典树】

​	没学过。后来学过了，前缀树要求实现insert、search、startsWith方法；先介绍一下前缀树。

​	前缀树是一棵26叉树；每一个结点具有26个孩子，分别对应26字母，因此孩子可以顺序存储了；前缀树的最大优点是快速查找是否插入过一个字符串或以当前输入字符串为前缀的字符串是否存在。

​	并不真正存储二十六个字母，因为孩子的下标就代表了字母。当需要search的一个字符串的时候，从第一个字符开始，从树根开始顺着孩子往下找。如果发现最后一个字符在查找时，对应的cur结点的属性is_end是true，则证明曾经插入过，所以查找成功。

​	所以插入的逻辑就知道了，顺着word往下找，如果发现为null，就new节点，依次迭代往下一边钻，一边检查，一边插入。最后修改cur的属性is_end为true代表这个单词插入完毕。

​	startsWith更好处理了，压根不需要检查结束标记。如果发现prefix遍历完都没有return，说明这条路径是存在的，最后return true就证明存在以prefix为前缀的路径。如果在循环中，发现路径堵塞-为null了，直接return false证明不存在。

10.【312】戳气球 - 【动态规划】

​	题意不难理解：给了一个数组，代表不同的气球，戳爆一个气球，你可以获得这个位置气球上的数值 * 左右两侧的气球的数值枚硬币。求戳爆所有气球获得的硬币的max；注意：如果是边缘的气球，你可以用1补全两侧缺陷。第二点，戳爆一个气球之后，你可以认为这个数从nums中消失了。

​	算了，想不出来，看看题解。

​	我从题解中获得了很多启发：①求最值的问题：最朴素的方法就是枚举所有的情况然后迭代最值，有两种算法实现枚举-回溯和dp；先看回溯：戳气球，使用回溯无非就是第一次戳哪个，有n种选择，第二次被戳的有多少种选择？这本质是一个全排列的问题。是阶乘的时间复杂度。很显然会超时。

​	所以只能考虑一下dp了。我们假设是一维的dp，很显然一维的dp解决不了问题。因为戳爆一个气球涉及到两侧的分数的问题，而且随着其他气球的爆炸，没有办法通过一个指针来遍历。所以考虑用双指针遍历，那就必须使用二维dp数组了。我们可以假设`dp[i][j]`是区间(i,j)之间的气球全部被戳爆得到的分数最大值。**（i<j必须满足）**

​	如何得到这个分数呢？那就需要中间的气球被戳爆，我尝试戳爆这个区间（i，j）范围内的一个气球k，很显然我缩小了范围，因为`dp[i][k]`和`dp[k][j]`我是可以构造出来的。这是子问题。所以我可以认为k是这个区间内最后一个被戳爆的气球。又因为是开区卷，所以状态转移方程就是两部分区间加起来 + 戳爆k气球的分数，即points[k] * points[i] * points[j]，为什么i和j是k相邻的气球？因为我们假设子问题已经解决了，即k是这个区间最后一个被戳爆的气球。

​	那么我们需要扩充原数组，把头和尾都插入一个1。这两个气球我们不戳爆。

​	很显然这个dp我们只需要构造上三角，即i<j的情况。我们要考虑我们的遍历顺序。我们需要遍历i和j区间内的每一个k，所以我需要确保这个区间内已经完成了构造，所以我的遍历顺序是往外走的，即一个正序，一个逆序。要确保i<j，而且要往两侧扩展，所以i要--，j要++的；开始写代码。

​	初始化为0，求max所以不影响。代码很优美，粘贴在这里

```C++
class Solution {
public:
    int maxCoins(vector<int>& nums) {
    	// 构造新的气球数组
    	int n = nums.size();
    	vector<int> balls(n+2,1);
    	for(int i = 1;i < balls.size()-1;i++) balls[i] = nums[i-1];
    	// 定义dp
    	vector<vector<int>> dp(n+2,vector<int>(n+2,0));
    	for(int i = n+1;i >= 0;i--) {
			for(int j = i+1;j <= n+1;j++) {
				for(int k = i+1;k < j;k++) {
					dp[i][j] = max(dp[i][j], dp[i][k] + dp[k][j] + balls[k]*balls[i]*balls[j]);
				}
			}
		}
		return dp[0][n+1];
    }
};
```

11.【238】除自身以外的数组的乘积 - 【前后缀乘】

​	【尝试除法思路】题目要求在O（n）的复杂度内完成本题，而且不能用除法，题目不能让我们使用整体之积除以自己的方法。我尝试一下用除法能不能ac。果然不行，因为可能数组中有0。

​	【尝试暴力】暴力:O（n^2^）,超时了-以后达到10^10^ 的运算次数肯定会超时的。

​	【前后缀乘】为什么暴力会超时？因为大量的重复计算。看看题解，类似于前缀和的思想。对于相邻的两个位置i和i+1,其实他们的结果中都有公共的部分，即小于i的部分的累乘，大于i+i部分的累乘。所以我们可以利用两个数组，一个数组left，一个数组right；left[i]存储i之前的所有数累乘的结果；right[i]存储i之后的所有数累乘的结果。最后构造一个ret数组，让left[i] * right[i]就好了。left[i]的构造就可以使用前缀乘的思路；而right[i]的构造就可以使用后缀乘的思路。

12.【560】和为K的子数组 - 【前缀和】

​	给我一个数组，一个k，问这个数组的和为K的子数组的数量？

​	暴力是O(n^3^)，因为遍历子数组需要两个指针-两层for循环，求和是O(n)。因为是区间求和，所以想到了前缀和，这样就可以降低复杂度为 O（n^2^）.

​	前缀和指的是，利用辅助数组prefix来记录包含下标i的左侧的所有数之和。好处是可以迅速查表求出区间和。假设已知prefix数组的每一个prefix[i]，如果已知指针j和k，通过prefix[k] - prefix[j-1]可以快速求出来[j,k]的和。

​	我总结出来一个骚操作：那就是在前缀和的题目中，前缀和数组最开始插入一个虚拟节点，方便统一代码格式。虽然说O(n^2^)，但是打败的人不多。题解说可以哈希加速，就这样吧。能前缀和ac就不错了。

13.【303】区域和检索 - 数组不可变 - 【前缀和-梦开始的地方】

​	-- 非hot 100

​	最朴素的前缀和。

​	学到的东西：动态数组vec作为类的属性，没必要用指针。用一般的变量就好，要想改变大小可以使用resize方法。eg：`prefix.resize(nums.size()+1);`

14.【304】二维数组区域和检索 - 矩阵不可变 - 【二维前缀和】

​	-- 非hot 100

​	类似，注意下标就好。

15.【139】单词拆分 - 【动态规划】

​	这个题我知道是背包问题，而且因为物品可以任意使用。是完全背包问题，所以遍历顺序肯定是正向遍历。不同的是，这个题目是有顺序的。而且一个物品前面用了后面还可能用，所以内层必须遍历物品。这样才能在构造dp的过程中，再次有机会使用到之前用过的物品。

​	所以外层遍历容量，内层遍历物品。可以使用一维数组dp[i]表示[0:i]能否由字典中的单词拼成。但是我们的外层的j是从最小容量wordDict[i].size()开始的，所以我们构造的其实是dp[j-1]，所以外层的遍历右侧最大值是s.size()，而不是s.size() - 1.这个细节要注意。

​	然后就是切片的时候的下标可以枚举一个简单的数确定。如果切片和当前遍历的字典的单词相同，就可以更新dp[j-1]了，当然可能最开始的时候，访问j-1-(int)wordDict[i].size()可能会越界，所以讨论它的合法性。如果不合法，直接确定dp[j-1]为true；否则应该取决于不考虑当前单词的情形，即等于 dp[j-1-wordDict[i].size()]，但是由于是遍历更新dp[j-1]的，所以如果之前为true过，那么也应该继续为true，所以只要dp[j-1]和dp[j-1-wordDict[i].size()]至少成立一个就好了。

​	细节不少。

```c++
class Solution {
public:
    bool wordBreak(string s, vector<string>& wordDict) {
    	vector<bool> dp(s.size(),false);
    	for(int j = 0;j <= s.size();j++) {
			for(int i = 0;i < wordDict.size();i++) {
				if(j < wordDict[i].size()) continue;
				string s1(s.begin()+j-wordDict[i].size(),s.begin()+j);
				if(s1 == wordDict[i]) {
					if(j-1-(int)wordDict[i].size() < 0) {
						dp[j-1] = true;
					}else {
						dp[j-1] = dp[j-1] || dp[j-1-wordDict[i].size()];
					}
				}
			}
		}		
		return dp[s.size()-1];
    }
};
```

## 7.31

-- 7月最后一天，加油gogogo~

1.【2683】相邻值的按位异或 - 【位运算】

​	每日一题。考察的是异或运算。倒是ac了。但是是擦边过，时间复杂度是O(n)也是最低了。不管了，就这样。本质上考了一个性质：如果a^b =c,那么有a^c = b，类似的，b^c = a.

​	original[0]是未知的，就可以假设它为1和0，original的其他部分可以由上述性质推得，最后根据首尾的元素异或验证是否等于derived的最后一个元素，只要有一种情况下成立，那么就存在这样的original可以推得derived，这是最好想出来的思路。

2.【23】合并K个升序链表 - 【链表\归并排序】

​	最笨的方法是两个两个合并，时间复杂度是O(mn)，看看能不能ac.过了，但是不是最好的方法。尽管我的方法没有使用额外的空间-除了哨兵。

​	教训：合并一个节点到一个升序的链表中要注意的可以先while寻找插入位置，然后最后插入。最后要么到尾巴，要么是找到了合适的条件。 第二就是不要忘了边界条件的检查，要确保你的代码对所有的数据范围的样例都有效（尽管有些题目确实垃圾，样例和提示给的范围不一致导致误人子弟）。

​	优化：由于是k个有序的链表，**归并排序中的某一层就是有若干个有序的数组**，然后通过merge实现了合并。所以这个题也可对lists进行分，然后最后两两合并。复杂度可以到O（logn * L）级别。

3.【287】寻找重复数 - 【哈希表】

​	这个题是寻找出现两次的那个数字，别的都出现了一次。位运算方法可以，但是很麻烦，我还是用负数标记法吧。

​	<u>这个题类似于448-所有数组中消失的数字。</u>

4.【4】寻找两个正序数组的中位数 - hard【分治】

​	注意两个数组的长度不同，就不能用之前等长的二分思路了。转化为在合并数组中寻找第k小的问题（如果合并区间的长度是偶数，那就是合并数组中中间两个数的平均数，如果是奇数，那就是中间那个数。总之可以通过一个辅助函数find_k，即在合并数组中寻找第k个数来实现）。

​	寻找第k小元素的策略是比较两个数组的第k/2个元素，取nums1的第k/2个元素a和nums2的第k/2个元素b，若a < b，则nums1的前k/2个元素一定在合并后的前k-1小元素中，可以排除，反之则排除nums2的前k/2个元素，之后将k更新为k - k/2，在剩下的部分中递归缩减问题规模继续查找。根据排除的策略可以确定入参除了nums1和nums2和k之外，还需要管理区间的左侧端点-右侧则不需要管，因为我们缩小范围的策略是只排除一个区间的前一部分。而不是两个区间同时缩小范围-如果这样的话才需要left和right两个端点来管理一个数组的一个区间。

​	这个题，应该是和KMP类似一样难的。

细节有很多，包括：

* 递归出口的处理-包括b1，b2，k都要处理；
* 下标的处理；
* mid_a和mid_b的初始化为什么是INT_MAX？
* 为什么k不需要分情况讨论奇偶数呢？

```c++
class Solution {
public:
	double find_k(vector<int>& nums1,vector<int>& nums2,int k,int b1,int b2) {
		// 寻找合并数组的第k个数
		if(b1>=nums1.size()) return nums2[b2+k-1];
		if(b2>=nums2.size()) return nums1[b1+k-1];
		if(k == 1) return min(nums1[b1], nums2[b2]);
		int mid_a = INT_MAX,mid_b = INT_MAX;
		if(b1 + k/2 - 1 < nums1.size()) {
			mid_a = nums1[b1 + k/2 - 1];
		}
		if(b2 + k/2 - 1 < nums2.size()) {
			mid_b = nums2[b2 + k/2 - 1];
		}
		if(mid_a <= mid_b) {
			return find_k(nums1, nums2, k - k/2, b1 + k/2, b2);
		}else {
			return find_k(nums1, nums2, k - k/2, b1, b2 + k/2);
		}	
	}
    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {
    	// 鲁棒性处理
        int m = nums1.size();
        int n = nums2.size();
        if(m == 0 and n == 0) {
			return 0.0;
		}else if(m == 0 and n != 0) {
			// 找nums2的中位数
			if(n % 2) {
				return nums2[n/2];
			}else {
				return (nums2[n/2] + nums2[n/2-1]) * 1.0 / 2;
			}
		}else if(m != 0 and n == 0) {
			// 找nums1的中位数
			if(m % 2) {
				return nums1[m/2];
			}else {
				return (nums1[m/2] + nums1[m/2-1]) * 1.0 / 2;
			}
		}
		// 都不为0，正常逻辑-寻找各自第(m+n)/4个数，确保两侧数字对齐
		if((m + n) % 2) {
			return find_k(nums1, nums2, (m+n)/2+1,0,0);
		}
		return (find_k(nums1, nums2, (m+n)/2, 0, 0) + find_k(nums1, nums2, (m+n)/2+1, 0, 0)) / 2;
    }
};
```

-- 奖励自己做几道位运算的简单题

5.【155】 最小栈 - 【数据结构设计】

​	我自己想不到，我想到了堆维护最小值，但是还是不行。看了题解，懂了，在正常的栈里面，维护一个正常元素，每个元素同时绑定一个全局栈的最小值。我感觉这样类似于在类内同时维护一个最小值。但是全局最小值维护不行，因为pop的时候，你没办法回溯状态。所以只能让元素绑定一个最小值-意思是“我入栈的时候的局部最小值”，“后来者还可能会刷新这个最小值，但是那和我无关了。”

​	所以用pair绑定就好了。

6.【11】盛最多水的容器 - 【双指针】

​	先试试暴力，O(n^2^)的。超时了。本质需要两个指针i和j表示区间的，所以可以尝试双指针。关键是如何更新指针。看了题解，指针的更新策略是：只更新一个，而不会两个同时变；谁的高度小，谁就改变。因为我们还是想让两个都高一些的。高的肯定不能积极的变换。

7.【240】搜索二维矩阵II

​	同一行升序，同一列也是升序。如果是一般的二维矩阵肯定是O(mn)暴力搜索，但是有这个升序的特点必须要利用起来，可以减少时间复杂度。优化到O （m+n），因为很多比较是无意义的。比如：如果我比你大，那么一定比我大的，肯定也比你大。这就类似于有一个人前来打擂台，教练派出小兵子都比你厉害，更没必要出动大将军了。因为我可以确定，我的右侧一定比我大。所以这就决定了遍历顺序，一定是从左侧往右侧查找，即j指针初始化一定是从0开始的。

​	确定从左侧往右侧遍历之后，确定在左上角还是左下角开门。如果在左上角开门，很显然左上角是全局最小的那个数，一定会比target小于等于的，所以这样就没有周转的必要的。

​	尝试从左下角开门，如果我比你大，我右侧的一定你比大，就可以省略比较次数简化复杂度；如果我比你小，那么我这一列上面的都比你小，也没必要遍历了，所以只能往右侧走。如果一样大，就返回true；最后返回false。

​	很巧妙。但是我第一次想不到。也正常。

---hot刷累了，写会二叉树放松一下。

8.【872】叶子相似的树 - 【二叉树的DFS】

​	关键是如何得到这个叶值序列，先序遍历就好了，如果遇到叶子，就加入序列；需要管理一个全局的序列；遍历第二棵树的时候，我需要操作第二个数组。所以还是别用全局的了，直接引用传递，最后比较就好了。一棵树操作一个序列。100% ac了，考察的是先序遍历。

9.【LCP 44】开幕式焰火 - 【二叉树的DFS】

10.【671】二叉树中第二小的节点 - 【二叉树的DFS】

​	纯暴力过了而且是100%ac，就是遍历这棵二叉树，那个性质根本没用到，然后统计次数，用一个`vector<pair<int,int>>`来作为哈希就好了。

## 8.1

1.【129】求根节点到叶节点的数字之和-【回溯】

​	这个题可以回溯得到所有的数，最后求和一下。和所有路径是一样的。注意路径的意思是路径拼成的数字，即从根到叶子的所有数拼在一起构成一个字符串，再转int，然后所有这样的路径加起来。

​	注意是不是会溢出。100%ac了，不会溢出。

注意事项：

* 这种我们到叶子就应该收集了；但是由于叶子也需要收集，所以应该先处理节点，然后检查是不是需要收集；
* 这样处理没有处理空节点的情况，所以就要在递归之前确保root不是空；递归和回溯配套就好了。

2.【1448】统计二叉树中好节点的数目 - 【二叉树的遍历】

​	不要想复杂了，不要什么都用回溯。因为回溯本质上是需要用到过程的记录算法！这个题优先考虑最朴素的方法，整棵树的好节点的数量应该是左子树的右子树的加起来，然后判断自己是不是好节点，如果是，也算上自己，若不是，就不算自己。可以用自己和参数传过来的比较。

​	路径上的最大值可以用参数传递。

教训：不确定优先级的时候，要加上括号！ CPP中的加法优先级肯定高于比较的。

`return l_num + r_num + (root->val >= m);`

3.【1457】二叉树中的伪回文路径 - 【回溯、哈希表、位运算】

​	这个题中要求求出所有从根到叶子的路径中，伪回文路径的数量；伪回文路径指的是，路径的排列中，存在一个回文序列；回文序列的特点是对称，个数可奇可偶，那么就简单了。直接统计一下路径中的次数，看看奇数数是不是1或者0个，因为奇数只能出现在中间才可以对称，如果>1个，说明不是伪回文路径。

​	那么我们可以先回溯找到所有路径，当然也可以一遍递归，一遍处理路径。即在遍历的过程中，如果一个数在当前的路径中出现过，我就修改它没有出现；如果没有出现过，我就让他出现过-可以通过和1异或实现。这样的好处是一对相同的数在路径中相互抵消，最后收集叶子的时候，我只需检查存在的元素个数是否大于1，如果大于1，那就不是伪回文序列。

​	ac了，回溯结合哈希表就可以解决了。

4.【1315】祖父节点值为偶数的节点和 - 【二叉树的DFS】

​	这个题要求找到所有这样的节点的值的和：它的父节点的父节点是偶数。如果不存在这样的节点，返回0；

​	分析：我们倒过来想一下就好了。如果我自己是偶数，那我就尝试加起来我的左右孩子的孩子们的值就好了-前提是存在。然后递归下去就好了。把鲁棒性做好就OK了。

​	第一次就ac了。

5.【988】从叶节点开始的最小字符串 - 【回溯】

​	要求从叶子到根构成的str，所有这样的str中，最小的字符串是什么。

​	所以本质还是回溯。我们可以最暴力的手段处理，即回溯放入ret，然后分别reverse翻转，最后sort，直接返回第一个就好了。回溯复杂度还是O(n)，假设叶子的个数是O（logn）,所以排序的复杂度是（lognlog（logn）），翻转的复杂度是高度O（logn * logn） ，整体上还是O(n).

​	【优化】：看到了网友的回答，确实，最后不需要sort，而是只需要返回一个最小值，正好CPP也是可以支持字符串的比较的。确实这样就可以100ac了。

6.【1026】节点与祖先之间的最大差值 - 【回溯】

​	分析：为每一个节点都在所在的路径上，计算和祖先的差值，并尝试更新全局的max_val。ac了，但是效果不是最好的，因为有大量的重复计算。

7.【1022】根到叶的二进制数之和 - 【回溯、位运算】

​	回溯，一样的属于路径的题目，都是一个套路，找到路径，最后集中处理，属于模版题目。需要一个str到int的辅助转换函数。但是这样好像有点麻烦，我直接利用左移和右移实现push的操作，回溯的时候就逆着来就行，不需要走字符串这档，因为人家的1和0就是int，我们可以借助位运算。

​	教训： 不确定优先级要加括号，还有<<这种移位运算符也是可以复合赋值来玩的。

`path = (path << 1) + root->val;`

8.【623】在二叉树中增加一行 - 【二叉树的层序遍历】

​	这个题目由于要操作一整行，然后对这一整行做怎么样的操作，用层序遍历是最简单的想法；先找depth-1行，然后一层for循环遍历这个队列进行层序处理就好了。对于depth == 1的特殊情况特殊处理就好。

​	属于层序遍历的模版题。100%ac了。

## 8.4

-- 本周的最后一天，目标15题 - 还是刷二叉树-今天刷BST

1.【783】二叉搜索树节点的最小距离

​	利用到了BST的中序遍历是一个升序的数组，放入数组之中，然后遍历两两之间的差值，得到最小值即可。非常简单BST题目。

2.【938】二叉搜索树的范围和

​	给了一个区间，让我把BST中所有节点的值在此范围内的，加起来返回。

​	可以利用BST的性质进行剪枝，没必要遍历整棵树，如果我自己的val都小于low，那我的左子树也要cut；类似，如果我val大于high，也没必要遍历我的右子树了。全局sum收集结果。

3.【230】二叉搜索树中第K小的元素

​	太简单了，比第783题目还简单。

4.【1305】两棵二叉搜索树中的所有元素

​	相当于合并两个有序列表，基本原理还是第230这个题目的性质。

5.【897】递增顺序搜索树

​	中序遍历，节点入vec，修改指针，最后返回root即可。

​	细节：最后一个节点单独处理左右孩子置空，这一点要注意，因为中序遍历的最后一个节点不一定是叶子节点，左子树仍然可能不是空。

6.【653】两数之和④-输入二叉搜索树

​	还是中序遍历，然后双指针操作。

7.【108】将有序数组转换为二叉搜索树

​	其实是转化为AVL，不过都有序了，直接二分就会平均。

8.【998】最大二叉树②

​	最简单的思路是逆着规则复原这棵树的a列表，追加val之后构造b，然后根据规则构造一个新树。ac了，【但是可以优化，我这里就先不优化了】。

9.【1008】前序遍历构造二叉搜索树

10.【1382】将二叉搜索树变平衡

​	我们之前学的那种四种旋转方式，其实是通用的把一棵树平衡化的过程。不是特意针对BST的，但是如果要用到BST，那可能会不太一样。

​	因为BST的最核心的性质就是中序遍历是有序的数组，根据一个有序数组进行构建AVL是简单的。就这么做，也是最优解。时间复杂度是O（n），主要是中序遍历BST的部分。

11.【103】二叉树的锯齿形层序遍历

​	分析：题意是第一行从左往右层序遍历，第二层从右侧往左侧，以此类推。返回一个二维数组；其实很简单。你只需要对偶数的部分reverse一下就好了。

12.【1161】最大层内元素和

​	模版题。

13.【2583】二叉树中的第K大层和

​	直接暴力吧。

14.【1302】层数最深叶子节点的和

​	最后一层一定是层数最深，而且都是叶子，把最后一层加起来就行了。关键是如何判断是最后一层，我可以把每一层都加起来，返回最后那个，但是作了很多无用功。也可以迭代一个sum。这样就可以了。

15.【2415】反转二叉树的奇数层

​	相当于偶数层，需要反转，用双指针遍历每一层swap就行了。

16.【1609】奇偶树

## 尝试过

1.【993】二叉树的堂兄弟节点

2.【958】二叉树的完全性检验 

3.【662】二叉树的最大宽度

4.【2476】二叉搜索树最近节点查询

5.【1373】二叉搜索树的最大键值和

6.【2196】根据描述创建二叉树

7.【889】根据前序和后序遍历构造二叉树

8.【2471】逐层排序二叉树所需的最少操作数目

9.【99】恢复二叉搜索树



​	