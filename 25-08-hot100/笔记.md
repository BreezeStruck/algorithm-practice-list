===========================7.29==========================

1.【234】回文链表 

​	分析：如果可以用辅助数组确实很简单**-copy+双指针就好了**。但是我想挑战一下空间复杂度O(1)；我想不出来，因为诶这个题目需要修改链表结构，即把链表的**后半部分反转一下，然后从后半部分开始一个指针，从最开始开始一个指针比较是否相同**，然后此方法存在并发控制的问题，因为涉及到了对链表进行写操作。所以还是有弊端的。这个思路挺好的了解一下，但是想要ac这个题目，还是copy+双指针吧。用递归的空间复杂度也是O（n）。

​	毕竟我们不是找工作面试，所以不需要管这些优化的问题。

2.【215】数组中的第 K 个最大元素【计数排序】

​	分析：减治法，这个题目我看了题解才知道；我本来想的是类似于堆排序的思路，复杂度是O（n * k）,不太稳定。要想实现O(n)，可以考虑减治法，但是实际操作下来类似于快速排序的快速选择方法还是在某种情况下退化到O(n^2^),所以还是会超时。

​	注意事项：索性就用空间换时间，用桶的思想排序吧还是。注意桶排序的时候，**<u>比如5的个数有100个，不要只push一次，而是要把100次就放如结果数组中。</u>**

3.【21】合并两个有序链表  分析：简单题目，类似于合并两个有序数组一样。

4.【5】最长回文子串【中心扩散法】

​	ac了，但是效率比较低。我是遍历s的每一个位置，然后利用回文的性质尝试往外扩散，然后奇数和偶数的情况都要试一试，因为你不知道回文串的长度是奇数还是偶数；所以要套两遍，复杂度是O(n^2^)的。已经尽力在避免重复判断回文了。我看题解里面dp的复杂度也不高，所以还是O(n^2^),而纯暴力是没有办法ac的。所以我的复杂度还算可以了。（我的中心扩散法应该是比较合理的方法了。能想到这个应该是对回文有比较好的理解了。）

​	优化奇偶：当发现连续的字符就把他们当做一个整体扩散。避免了重复计算。

5.【169】多数元素【摩尔投票法】

​	统计 + 找最大值秒了。时间复杂度和空间复杂度都是O（n）。但是这个题目还有一种我没学过的思路：

【摩尔投票法】

【【剑指Offer最优解】 39. 数组中出现次数超过一半的数字 ｜ 摩尔斯投票法】https://www.bilibili.com/video/BV1UB4y157UP?vd_source=db337c2a2fa9fcee88212163237d3921

​	学一下。懂了。这个摩尔投票法适用于一切寻找众数的方法。核心思路就是抵消。想象这样一个场景：要选举一个班长，A和B如果是最后决战的两个同学，他们一个人有50票，一个有49票，其实就和一个1票，一个0票没区别。反正第一个同学的投票数就摆在那，它是最有“钱”的，即抵抗消除能力最强的那个。

​	我们最开始是不知道谁是班长的，所以只能假设第一个人是，然后往后遍历，发现是投自己的，计数器就++；发现不是投自己的，就--，如果发现--完成之后是0，说明自己就被杀死了。同时，其它和我陪葬的人都死了。但是无所谓，如果我是最后的班长，后面仍然有我的身影，我依然有机会。从这个角度来看，是一个 “全局桶”的思想。一旦我被杀死。数组就缩小了。但是仍然不会影响最后的众数。

​	写一下代码，这个复杂度最低，时间是O(n)，空间是O（1）的，你只需要维护一个cnt，一个candidate；

6.【229】多数元素II  【摩尔投票法】

​	本次不是hot一百的题目，而是上面的题目的扩展。这个要求找出所有出现频率超过>n/3的数。

​	先说结论：摩尔投票发可以扩展到[n/k]的情形，而且很容易得到，次数超过[n/k] (向下取整)的数不超过k-1个。要澄清一件事：摩尔投票法不是用来求一个数组的最高频率元素的-即不是直接寻找众数的办法！！！因为前面的抵消会对本身是众数的结果产生影响。

​	**摩尔投票不是用来求众数的！！！**（即能用摩尔投票法做的求出来的一定是众数，但是求众数不一定可以用摩尔投票法来做，前提是你得保证众数超过多少百分比，如50%，33.3%等）所以你想求两次众数的想法就可以打消了。正确的做法是：

​	一层循环，同时维护两个最有希望的投票人。而不是顺序先找第一个，再找第二个。那样找不出来的-因为摩尔投票不是用来寻找众数的。同时维护两个。分多钟情况更新就好了。

​	最后还是需要判断一下选出来的这两个票数最多的人是不是满足条件才可以。

**注意事项：**

* 关于初始化：初始化0就行了，如果真的0，那也不影响；然后从下标0开始遍历就好了；
* **<u>关于判断顺序</u>**：**先判断是不是相同，然后判断是不是cnt为0（只能这样，不能换顺序，它不同于n/2的那种，这个怎么顺序都行）**；如果都不是，两个都需要--，相当于这个元素和它俩互相残杀。为什么是它俩同时cnt--呢？因为你就这么想，它俩都不和nums[i]相同，那就同时减少一票就好了。也只有这个时候才能抵消票数，为了公平必须同时减少票数。

7.【141】环形链表  【链表、哈希表】

​	分析：这个题是1，代码随想录上是2；这个简单一点，只是判断是不是有环，另一个是要找到入口；我仍然采用hash的做法。都可以秒掉。

8.【136】只出现一次的数字 【位运算】

​	这个题的题意是除了答案，别的数在数组中都出现了一次，要求在线性时间复杂度范围和常数空间复杂度范围解决。 哈希不满足，想不到。

​	看题解。用到了位运算，即异或运算，从bit的角度思考问题，如果两个数在数组中出现了两次，异或之后肯定是0，所以最后的答案肯定就是单数出现次数的那个。聪明！！！

​	但是我好像没用过异或运算。学习一下。	异或的算符是  `^`. 三行代码就解决了。本质上还是用到了异或的可交换这个性质。出现过两次的异或失效！！！

```C++
class Solution {
public:
    int singleNumber(vector<int>& nums) {
        int ret = 0;
        for(int n:nums) ret ^= n;
        return ret;
    }
};
```

9.【283】移动零【双指针】

​	这个题看起来很亲切，要求我使用原地操作，完成所有的0移动到数组的末尾。其实我一开始就想到了快慢双指针移动删除所有的指定元素那道题。只是那道题之后不需要在意后续的操作，这个只是把后面赋值为0罢了。

10.【338】比特位计数 【动态规划】

​	这道题暴力是O(nlogn)，即每一个都要重复count 1的个数。

​	可以使用动态规划，结合语境得到状态转移方程，甚至dp数组就是要返回的结果；其实这种需要为连续的、有关系的数字串构造一个东西的这种，都可以考虑dp，试图从语境中寻找关系。

​	一个数要么是偶数，要么是奇数；如果是奇数，则1的个数比小于它的最大偶数多1个，即末尾的1；如果是偶数，则其中含1的个数和它除以2的格式一样多，即和它右移一位的数含1的个数一样多，因为偶数末尾一定是0.就可以写了。

11.【543】二叉树直径 【二叉树、递归】

​	分析：这个题目就是暴力，写一个求最大深度的函数，然后深度搜索每一个节点，维护一个全局的max_path，对于每一个节点，都看看左右子树的最大深度之和是不是最大值，然后尝试更新最大值就好了。

​	优化：由于求深度和DFS都是在搜索这棵树，所以可以合并到一个递归函数里面去。这样其实才是最优解。

12.【461】汉明距离 - 【位运算】

​	有了上面的找出现一次的数字的那个题目的异或的经验，这个题目用异或就很简单。汉明距离是二进制不同的位置的数目。异或之后，只有不同的，结果才是1；然后数一下1的个数就好了 - 循环右移的思路，让cnt += 末位数（和1按位与运算）

唯一注意的是：**<u>右移或左移</u>**是一个算符，和加法一样，**<u>需要赋值生效的</u>**。

13.【448】找到所有数组中消失的数字 - 【哈希表】

​	这个题哈希统计肯定是可以ac的，但是不是最优解，即没有办法通过高阶的。最优要求空间复杂度是O（1）；但是经过我的思考，我发现很多题目你要想把空间复杂度降下去。就得修改原来的数据结构。而不能通过只读的方式实现O(1)的空间复杂度。

​	看下题解，这个题果然要实现O(1)的空间复杂度，就必须修改nums；这个题的灵感在于，nums的长度是n，然后要统计的也是n；那么我们就直接让nums作为一个哈希，关键点来了：对于数字nums[i]，其位置应该在i-1的位置上，如果这个数没出现过，我就让nums[i-1] 乘以-1变为一个负数，如果出现过了，注意，这个时候由于nums已经被修改过了。我们不要再负数的基础上在++，或者--了；我们需要先拿到复原之前的结果，继续处理下去！！！这样也不需要担心负数再次++恢复正数了。

​	最后统计一次，如果是正数，证明对应的位置没出现过。	开始很容易出错。

​	nums[i]可能是正数或负数，但是一定要取正数，确保访问index不越界；再就是判断这个n代表的哈希位置，即n-1为索引的num，是不是已经被访问过了。如果没有（>0）,那就需要设置为负数。

```C++
class Solution {
public:
    vector<int> findDisappearedNumbers(vector<int>& nums) {
        vector<int> ret;
        for(int i = 0;i < nums.size();i++) {
        	int n = nums[i] > 0?nums[i]:-nums[i];
			if(nums[n-1] > 0) {
				nums[n-1] *= -1;
			}
		}
		for(int i = 0;i < nums.size();i++) {
			if(nums[i] > 0) ret.push_back(i+1);
		}
		return ret;
    }
};
```

=======================7.30=======================

14.【2】两数相加 - 【链表】

​	遍历链表，把数构造出来，加起来，再头插法构造链表。时间复杂度是O(m+n)，空间复杂度都一样。是O(max(m,n));这种方法不行，long long也有几个方法过不了，故意卡的，暴力肯定不行了。

​	所以就必须逐位相加，考虑提示中的数字的范围是[1,100]，所以必须考虑进位。类似于加法器的思路吧。既然是逆序，开始的时候是小数，所以我们也采用这种思路。从小位开始加。如果当前两位和上一位的进位之和溢出（>10），我们只保存当前的个位数插入节点，然后把进位放入下一位处理。

​	看了题解之后，我感觉评论都忽略了数字的范围是[1,100]这个条件，好像默认范围是[0,9]，我们姑且这么认为。那么最大进位1和9和9也不会超过20，所以我们就采用朴素的方法。

​	从前往后遍历节点，保存结果，解析出来待插入节点的value -> sum % 10，进位则是sum/10，可能是1或0，下一轮的时候加上就好了。

​	但是链表最后可能有一个就是空了，因为链表不一定等长，那就让另一个为0就好了，也就是说要求求和的过程是分别进行的，累积的过程，而不是相加的过程。这样就保证了两个链表的独立性。

​	一会我们再来评价这个题的节点数值范围的问题。

评价和反思

* 最高位的进位要最后单独处理；
* 这个题的数值范围就是一坨狗屎，垃圾题目。给的节点范围是[1,100]，实际上测试全是[0,9]，一坨狗屎。

15.【22】括号生成 - 【回溯】

​	范围不大，需要中间结果，我第一印象却没有想到回溯，看来算法思维还没有形成，还得练。

​	每一个path的长度最后都是一样的，都是2n，所以这个树的深度一定是2n，每一层而言，只有两个结点。一个是左一个是右。很显然，维护两个变量，一个是左括号的数量，一个是右括号的数量，可以剪枝。因为满足左括号<n,右括号也是<n。

​	现在的难点在于怎么确保path顺着有效的括号方向发展呢。要么就放的时候放好，要么最后收集之前验证。显然验证的方法太费时间了。放之前就放好。如何约束呢？你要确保，path中的左括号的数量永远>=右括号的数量，**<u>即剩余的括号数量永远做到右侧括号的数量>=左侧括号的数量；</u>** 直接开始写代码。ac了。**太漂亮了这剪枝**。

```c++
class Solution {
public:
	int l_leave;
	int r_leave;
	vector<string> ret;
	string path;
	void backtracking(int n) {
		if(path.size() == 2*n) {
			ret.push_back(path);
		}
		
		// 左括号
		if(l_leave > 0 and r_leave >= l_leave) {
			path.push_back('(');
			l_leave --;
			backtracking(n);
			l_leave ++;
			path.pop_back();
		}

		// 右括号
		if(r_leave > 0 and r_leave >= l_leave) {
			path.push_back(')');
			r_leave --;
			backtracking(n);
			r_leave ++;
			path.pop_back();
		}
	}
    vector<string> generateParenthesis(int n) {
    	l_leave = n;
    	r_leave = n;
    	backtracking(n);
    	return ret;
    }
};
```

===> 第二轮惩罚开始了-15题-启动！！！ <===

1.【48】旋转图像 - 【数组】

​	把一个正方形矩阵右旋90度，思考之后发现，可以对角互换，然后再左右翻转。

2.【49】字母异位词分组 - 【哈希表】

​	暴力先试试吧，由于每一个string的长度不大，所以比较字母异位词可以看做是 O(1)的操作，外层循环面向strs的各个字符串，然后和每一个分组的第一个比较是不是字母异位词。整体复杂度是O(n^2^);

​	能否优化到O(nlogn)或者O(n)呢？估计不太行。先写一下暴力吧。暴力超时了。

​	**但还是从暴力中吸取了一个教训**：在使用**<u>增强for循环</u>**进行**<u>写</u>**的时候，要用`auto & x：ret`，注意引用，否则只是修改了x的副本，而没有修改x，进而没有让ret造成影响。

​	方法就是运用了字母异位词分组的依据是字母异位词，**所以可以对字符串进行排序**，把相同排序的字符串放入同一个哈希表-value是一个Vec就好，最后收集哈希表的value构造ret。排序的开销忽略不计为O（1）,所以整体的时间复杂度是O（n）。

3.【64】最小路径和 - 【动态规划】

​	求最小路径和，题目背景和动态规划章节的不同的路径是一样的，很显然这个题目也可以dp，因为这种棋盘上dp很容易，要么就从上面来，要么是左侧来，求一个min，在加上自己就好了。

​	简单题，直接ac了。

4.【114】二叉树展开为链表 【二叉树的dfs】

​	这个题用辅助空间的话不难，关键是能不能原地修改二叉树呢？看看题解。

​	倒着想，结果是一棵右斜树，而且从上到下是先序遍历的顺序。我之前想过一个问题。那就是要修改一个结点的右侧指针，你最好确保右侧的子树已经访问过了。这样你修改自己的右指针才不会导致“孤岛”；从结果上来看，先访问右子树，就得到了一棵树的最“右侧”的节点，即结果最下面的节点。按照这个思路，我们可以对链表进行头插。

​	先序是根左右，我们可以逆序来，右 -> 左 -> 根，这样就可以进行头插构造这棵斜树了。我们无需new新的节点。可以使用一个虚拟头结点。写一下吧。

​	写起来还是很简单的，要有一个mindset，即右子树和左子树都递归处理好了，我如何处理呢？就是把我自己头插到list就好了。左右手都可以解放了，右手指向list的right，左手指向null...

​	压根不需要记住什么遍历的上一个结点，完全没必要。

5.【148】排序链表 【链表】

​	



​	











​	