========================7.25========================

1.【122】买卖股票的最佳时机 II

​	这道题DP可以ac过；但是也可以贪心；这题贪心的思路很巧妙；股票一次买入和卖出，所得到的利润是可以分解为相邻两天的利润之和的，只是数学上，中间的过程都消掉了。以第零天买入，第三天卖出为例，利润 = prices[3] - prices[0] = (prices[3]-prices[2]) + (prices[2]-prices[1]) + (rices[1]-prices[0]) ; 所以就看出规律来了，实际上不管你中间经过了多少次买卖，即不管你经历了多少段，都可以微分下去，一直到相邻两天的买入和卖出。

​	都是由基本的相邻两天的利润构成的。既然是多只股票，那我就可以只挑正的利润就好了。也就是说，反正是多只股票，我只要挣钱我就加进去，只要遇到了亏损，我就卖出去。

​	代码就很好写了。借用一句大佬的话“相当于每天都在买卖”。

2.【53】最大子序和

​	这个最大子数组的和也可以dp，试试贪心。不会。看看题解。这个题目的贪心并不是很好想；这个题目的难点在于，连续子数组的最大和。你不能看到负数就收手，因为后面可能还有更大正数；而当下的负数以及之前已经收集的子数组之和还有可能大于0，即对结果有正向的作用。这就是这个题的难点。

​	我们可以用两个变量max_sum，一个是count，max_sum负责管理和迭代最大值，因为整个nums 的连续子数组的最大值出现在何处是不知道的。只能更新。而count就像是游历变量；负责管理和记录当前收集的情况。只要count还>0，它就会继续收集，但是count不会是最后返回的结果。因为count游历到最后，不一定是全局最优解。只能说是大于0的**<u>一个解</u>**.所以才需要max_sum来管理最大值。

​	只要发现count>max_sum，就可以更新一次max_sum；而count的更新规则是，先加上，只要count还有希望（count > 0），就不做处理，只要发现<0，那就置0；

​	而max_sum是管理最大值的，存在所有数都是负数的情况，所以你不知道max_sum有多小，也不一定是正数；所以初始化为最小数。

代码如下：

```c++
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        int max_sum = INT_MIN;
        int count = 0;
        for(int n : nums) {
			count += n;
			if(count > max_sum) {
				max_sum = count;
			}
			if(count < 0) count = 0;
		}
		return max_sum;
    }
};
```

3.【376】摆动序列

​	看看题解。这个题目的难度真的不小。因为考虑的东西很杂乱。判断峰值只是一种直观的解题的大概思路。但是要兼顾很多细节。比如如何处理平坡，平坡也会分为几种情况。包括端点如何处理。

​	本题中我们需要计算当前便利点的前面和后面的gap，如果gap>0说明是上坡，如果小于0说明是下坡，如果等于0说明是平坡。

​	本题的特殊情况有三种：①上下坡中有平坡，形如下图。这种情况算平坡只算一次峰值；而且平坡可能会很长。所以我们不应该时时刻刻更新preDiff，应该让prediff记录在上坡或下坡的位置，然后让curDiff去游历，它可能为0可能为正可能为负；这种平坡的，只有到了右侧的拐点，才会让ret++；换句话说，只要看到curDiff为0，就不会让curDiff++；而且当遍历到右侧拐点的时候，curDiff不为0了，**<u>而且之前没更新的preDiff也不为0（因为curDiff为0的情况下，不会更新峰值，也不会更新preDiff，除非初始化的时候preDiff=0，没办法，所以判断的条件的地方才会让preDiff的不等号加上等于号）</u>**，就可以用判断峰值的条件判断了，但是此时要更新preDiff为curDiff了，现在的判断峰值的条件是`if(preDiff<=0 and curDiff>0 or preDiff>=0 and curDiff<0)`

<img src="第三周.assets/1753420605464.png" width="400px">

​	②上坡或者下坡的过程中遇到了平坡；如下图所示。在上面的条件中，这种情况包含在内。平坡的左侧拐点，curDiff=0所以不会++，也不会更新；平坡的右侧拐点，因为preDiff>0，所以也不会更新。以左边的为例，因为如果第一个点是真实的左边界，那就会在这里更新一次。preDiff会变成curDiff的值，即一个大于0的数，显然不会在平坡的右边++并更新preDiff；如果前面存在一次极小值，那么preDiff也同样会被更新为大于0的数，不管怎么样，这种情况下，preDiff一定是大于0的数。

<img src="第三周.assets/1753421136796.png" width="300px">

​	③边界。如果整个序列是非严格单调的，返回2才对；按照我们之前的逻辑，中间是没有峰值++的；但是这种情况不同于所有数都相同的序列，那种算1；所以应该让整个序列的峰值数初始化为1，然后在第一次不水平处更新一次。即preDiff应该初始化为0，因为你也不知道curDiff第一次不水平遇到的是上坡还是下坡，反正判峰值的条件里面的preDiff那里都有=0的部分。

​	分析完毕。

4.【455】分发饼干

​	分析：有几个饼干，几个孩子；现在一个孩子最多吃一个饼干。有孩子的胃口值，饼干补充的饥饿值；现在求最多满足多少个孩子的胃口。

​	我最直观的想法就是贪心，把胃口和饼干都降序排序一下。然后我分发饼干。先分发大的饼干，直到找到第一个可以吃了这个大饼干就满足的孩子，之前那些大胃王我就不用管了，因为下面要分发的小饼干肯定无法满足这些小馋猫们的胃口了。所以外层是遍历饼干的。但是内层肯定不能是for循环了。必须用一个idx来代表当前遍历到哪个孩子了。对于每一个饼干，我只需要从上一次的idx处开始询问“你够不够吃”。那很显然，最后孩子遍历完毕的时候，剩下多少饼干，我就返回多少。或者最后饼干遍历完毕，我只就return 饼干的size就可以了。

​	还有一种策略：就是遍历孩子，但是我不太好理解。我这种也ac了。

注意事项：

​	要注意，跳过那些大胃王idx需要++，喂一个孩子也需要手动idx++，不要丢掉这种情况。

5.【1005】K次取反后最大化的数组和

​	真的很简单的一道题目；关键就是先升序排序，尽最大努力把绝对值大的负数先求相反数；出来之后比一下k是不是大于0，就知道负数和k谁多了。

​	有点细节就是循环的条件不要非法就行。而且这种排序的思路是最好的贪心思路了。

6.【738】单调递增的数字

​	分析：这个题目，肯定不能暴力。我们用贪心。如果从前往后遍历，显然是不行的；因为一旦发现两个数组是单调递减的，必然要把右侧的数改为9，而不能在左侧的基础上+1，因为要找到 <= 原数字的单调递增的新数。而右侧一旦改为9，左侧就要-1；左侧变小，可能就会影响更左侧的状态。所以必须从右侧往左侧遍历。

​	但是代码不太好写。主要是遇到0的情况。你不知道改哪位，而且你改了一次，整体仍然可能也并不符合条件。很显然,在某种情况下应该是从某一个位置后面都是9，**<u>因为只要出现了非单调递增的数对，就必然要涉及到置9，那么这个9后面也必然是9.</u>** 我们不妨找到一个位置，最后再统一置9.

​	那这个位置是什么位置呢？不太好一次就确定，因为我们是从右侧往左侧检查的，不可能第一次出现的位置就是最后的结果，应该flag是不断迭代到最左侧的。

​	所以代码就比较好写了；就是不断迭代idx到最左侧。但是每一次你就当做最后一次，修改一下左侧的值，让
它--，而且你不需要担心越界，因为递减的情况必然不会越界。

注意事项：

​	不要让idx_9初始化为最后一个，因为默认是不会出现逆序的。

7.【968】监控二叉树

​	这是一道hard题，而且我之前没有挑战过。我看了题解理解了。

​	这道题目的关键在于叶子节点肯定不会装，因为叶子肯定有父节点，把这个任务交给父亲就可以了；在叶子结点上装就是浪费。而且叶子的数量要很大，产生的影响远大于一个根节点，所以是自底往上遍历的，即后序遍历。

​	我们需要一个全局变量来控制监控的数量，所以在类内声明一个属性ret来管理监控的数量。

​	确定后序遍历之后，我们就要思考如何贪心让结果最小：为了让结果不多余，即降低同一个节点被重复照亮的可能性，即每个节点最好只是被一个监控照亮。那么我们设置三种状态，并且让递归返回当前节点的状态才可以方便判断。一个节点有三种状态：①我自己就是监控；②我被间接照亮； ③我还没有被照亮。 这三种状态分别用1和2和3管理。

​	递归函数可以这样写：如果是空，完全不用担心空的状态，return 2； 如果我不是空，后序遍历；如果我是叶子，即左右孩子都是2，这种判断条件也间接说明了，如果我的左右孩子都已经被间接照亮，那么我也不需要担心装监控，这个时候不管我是不是叶子，还是说我的孩子们都被间接照亮，装监控的都不应该是我，否则就浪费了，即我的孩子们都会被重复覆盖。所以return 3，即我还没被照亮，需要被照亮。如果我的左右孩子**只要有一个**状态是3，那意味着我必须装监控了，因为他们就我一个父亲，如果我不装监控，它们就不会被覆盖到了。 其他情况都返回2，即间接照亮状态。

​	主函数的地方要判断root传入进去是不是3状态，如果是，需要ret++，即额外关心一下树根，因为树根可能没有被照亮。即是状态3的情况-因为root没有被父节点照亮的机会了。

​	就不难写出代码了。

